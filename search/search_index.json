{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"","title":"Home"},{"location":"docs/overview/","text":"\ud83c\udf89 Welcome This project is for network developers looking to build, deploy, and validate an edge network design with Juniper Apstra and RedHat Ansible . For those looking to get started with either network automation or VXLAN/EVPN fabrics, this project can help you get familiar with the concepts and technologies necessary for success. \u2753 How to use this guide The navigation menu on the left hand of this site will be the best method of navigating between the documents. Automation This is where we will cover the automation covered by our Ansible Collection. Information about Roles, Plugins, and Modules will be discussed in detail. The all-important code deep dive will be taking place here, as well as a discussion around the various tools provided within the project to make our lives easier. Network This can be considered optional if you're only here for the Ansible, but it's really cool too. We will cover topics like IP addressing, VXLAN/EVPN fabric design, and control-plane details. Lab Environment We have provided a lab in Juniper vLabs to accompany this guide; an EVE-NG topology file has also been provided for those without access to Juniper vLabs. This section can be considered optional, only to be referenced if you're planning to execute this project firsthand.","title":"Overview"},{"location":"docs/overview/#welcome","text":"This project is for network developers looking to build, deploy, and validate an edge network design with Juniper Apstra and RedHat Ansible . For those looking to get started with either network automation or VXLAN/EVPN fabrics, this project can help you get familiar with the concepts and technologies necessary for success.","title":"\ud83c\udf89 Welcome"},{"location":"docs/overview/#how-to-use-this-guide","text":"The navigation menu on the left hand of this site will be the best method of navigating between the documents.","title":"\u2753 How to use this guide"},{"location":"docs/overview/#automation","text":"This is where we will cover the automation covered by our Ansible Collection. Information about Roles, Plugins, and Modules will be discussed in detail. The all-important code deep dive will be taking place here, as well as a discussion around the various tools provided within the project to make our lives easier.","title":"Automation"},{"location":"docs/overview/#network","text":"This can be considered optional if you're only here for the Ansible, but it's really cool too. We will cover topics like IP addressing, VXLAN/EVPN fabric design, and control-plane details.","title":"Network"},{"location":"docs/overview/#lab-environment","text":"We have provided a lab in Juniper vLabs to accompany this guide; an EVE-NG topology file has also been provided for those without access to Juniper vLabs. This section can be considered optional, only to be referenced if you're planning to execute this project firsthand.","title":"Lab Environment"},{"location":"docs/lab/local/","text":"\ud83d\udccc Overview To get off the ground running with a local copy of this projects, start with making sure that you have the proper tools instead head of time. Local Requirements Technology Install Guide Docker install Poetry install Please make sure you have correct permissions to execute Setting up the enviornment Once you're ready for flight, start by cloning this repository to your workstation. git clone https://github.com/cdot65/apstra-edge-ansible.git After changing into the project's directory, create and activate a virtual environment with Poetry cd apstra-edge-ansible.git poetry install poetry shell Note: If you have EVE-NG running within your home, we have provided a sample EVE-NG lab file .","title":"Local"},{"location":"docs/lab/local/#overview","text":"To get off the ground running with a local copy of this projects, start with making sure that you have the proper tools instead head of time.","title":"\ud83d\udccc Overview"},{"location":"docs/lab/local/#local-requirements","text":"Technology Install Guide Docker install Poetry install Please make sure you have correct permissions to execute","title":"Local Requirements"},{"location":"docs/lab/local/#setting-up-the-enviornment","text":"Once you're ready for flight, start by cloning this repository to your workstation. git clone https://github.com/cdot65/apstra-edge-ansible.git After changing into the project's directory, create and activate a virtual environment with Poetry cd apstra-edge-ansible.git poetry install poetry shell Note: If you have EVE-NG running within your home, we have provided a sample EVE-NG lab file .","title":"Setting up the enviornment"},{"location":"docs/lab/vlabs/","text":"\ud83d\udccc Overview If you're interested in using your access to Juniper's vLabs, we have provided a blueprint named Apstra Edge: Ansible Log into Juniper vLabs in your web browser and visit the blueprint . Reserve it for as much time as you need When your topology is up and running, we'll focus our attention on the server labeled \"Automation\". Hover your mouse over the server and a pop-up menu will appear. Selecting SSH from the menu will find your browser jumping into an SSH session with the server. Change into the directory container our project, and perform a git pull operation to make sure you're using the latest copy. There will be a lot of updates, don't worry if the screen fills up. cd automation/apstra-edge-ansible git pull Activate your Python virtual environment by typing poetry shell , follow it with a which python to make sure your python execution path has been updated. poetry shell","title":"vLabs"},{"location":"docs/lab/vlabs/#overview","text":"If you're interested in using your access to Juniper's vLabs, we have provided a blueprint named Apstra Edge: Ansible Log into Juniper vLabs in your web browser and visit the blueprint . Reserve it for as much time as you need When your topology is up and running, we'll focus our attention on the server labeled \"Automation\". Hover your mouse over the server and a pop-up menu will appear. Selecting SSH from the menu will find your browser jumping into an SSH session with the server. Change into the directory container our project, and perform a git pull operation to make sure you're using the latest copy. There will be a lot of updates, don't worry if the screen fills up. cd automation/apstra-edge-ansible git pull Activate your Python virtual environment by typing poetry shell , follow it with a which python to make sure your python execution path has been updated. poetry shell","title":"\ud83d\udccc Overview"},{"location":"docs/network/overview/","text":"\ud83d\udccc Overview When talking about our network design, I will be referencing the following Juniper vLabs topology image below; the color tagging used within the topology makes it easier to associate a router to a specific role.","title":"Overview"},{"location":"docs/network/overview/#overview","text":"When talking about our network design, I will be referencing the following Juniper vLabs topology image below; the color tagging used within the topology makes it easier to associate a router to a specific role.","title":"\ud83d\udccc Overview"},{"location":"docs/network/vxlan/","text":"\ud83d\udccc Overview This section explains our VXLAN / EVPN fabric design. We will be using LDP for signaling labels, which will limit the features we can perform within the network while conversely making it easier to provision. ERB design Juniper Apstra will provision an edge-route-bridge (ERB) design","title":"Vxlan"},{"location":"docs/network/vxlan/#overview","text":"This section explains our VXLAN / EVPN fabric design. We will be using LDP for signaling labels, which will limit the features we can perform within the network while conversely making it easier to provision.","title":"\ud83d\udccc Overview"},{"location":"docs/network/vxlan/#erb-design","text":"Juniper Apstra will provision an edge-route-bridge (ERB) design","title":"ERB design"},{"location":"docs/terraform/build/addressbook/","text":"\ud83d\udccc Overview The cdot65.apstra.blueprint module will allow you to manage the configuration of your Blueprint within Apstra. Feature set as of version 0.0.15: manage Blueprints idempotent Example Here is a basic example of using the module to manage your blueprint's configuration in Apstra - name : \"### CREATE BLUEPRINT cicd_template\" cdot65.apstra.blueprint : # define apstra server parameters server : \"apstra.dmz.home\" api_token : \"{{ api_token }}\" # define blueprint parameters design : \"two_stage_l3clos\" init_type : \"template_reference\" template_id : \"{{ templates['data']['id'] }}\" label : \"cicd_template\" # define whether to create or delete the blueprint state : present Options If you'd like to see the options available for you within the module, have a look at the data model provided below. Option Type Description api_token string our API token to authenticate with Apstra design string reference to our Design's UUID label string associate a label with our blueprint port int port number server string Apstra's DNS hostname or IP address state string determine whether to create or delete blueprint template_id string reference to our Template's UUID validate_certs bool enable or disable SSL certificate validation Data Model We can also get insight on all available options, and their expected input types, by looking at the module's data model. @staticmethod def blueprint_spec (): return dict ( api_token = dict ( required = True , fallback = ( env_fallback , [ 'APSTRA_API_TOKEN' , 'APSTRA_API_TOKEN' , 'API_TOKEN' ]), no_log = True , type = 'str' ), design = dict ( required = False , type = 'str' ), init_type = dict ( required = False , type = 'str' ), label = dict ( required = True , type = 'str' ), template_id = dict ( required = False , type = 'str' ), port = dict ( required = False , type = 'int' ), server = dict ( required = False , type = 'str' ), state = dict ( required = True , choices = [ 'absent' , 'present' ], type = 'str' ), validate_certs = dict ( type = 'bool' , required = False , default = False ), )","title":"Build"},{"location":"docs/terraform/build/addressbook/#overview","text":"The cdot65.apstra.blueprint module will allow you to manage the configuration of your Blueprint within Apstra. Feature set as of version 0.0.15: manage Blueprints idempotent","title":"\ud83d\udccc Overview"},{"location":"docs/terraform/build/addressbook/#example","text":"Here is a basic example of using the module to manage your blueprint's configuration in Apstra - name : \"### CREATE BLUEPRINT cicd_template\" cdot65.apstra.blueprint : # define apstra server parameters server : \"apstra.dmz.home\" api_token : \"{{ api_token }}\" # define blueprint parameters design : \"two_stage_l3clos\" init_type : \"template_reference\" template_id : \"{{ templates['data']['id'] }}\" label : \"cicd_template\" # define whether to create or delete the blueprint state : present","title":"Example"},{"location":"docs/terraform/build/addressbook/#options","text":"If you'd like to see the options available for you within the module, have a look at the data model provided below. Option Type Description api_token string our API token to authenticate with Apstra design string reference to our Design's UUID label string associate a label with our blueprint port int port number server string Apstra's DNS hostname or IP address state string determine whether to create or delete blueprint template_id string reference to our Template's UUID validate_certs bool enable or disable SSL certificate validation","title":"Options"},{"location":"docs/terraform/build/addressbook/#data-model","text":"We can also get insight on all available options, and their expected input types, by looking at the module's data model. @staticmethod def blueprint_spec (): return dict ( api_token = dict ( required = True , fallback = ( env_fallback , [ 'APSTRA_API_TOKEN' , 'APSTRA_API_TOKEN' , 'API_TOKEN' ]), no_log = True , type = 'str' ), design = dict ( required = False , type = 'str' ), init_type = dict ( required = False , type = 'str' ), label = dict ( required = True , type = 'str' ), template_id = dict ( required = False , type = 'str' ), port = dict ( required = False , type = 'int' ), server = dict ( required = False , type = 'str' ), state = dict ( required = True , choices = [ 'absent' , 'present' ], type = 'str' ), validate_certs = dict ( type = 'bool' , required = False , default = False ), )","title":"Data Model"},{"location":"docs/terraform/build/ike/","text":"\ud83d\udccc Overview The cdot65.apstra.design module will allow you to manage your design elements within Apstra. Feature set as of version 0.0.14: manage Logical Devices, Rack Types, Templates, Intereface Mapping idempotent Suported Resources: Design Element How to specify within Ansible module parameter \"type\" Interface Mapping interface-maps Logical Device logical-devices Rack Types rack-types Templates templates Example - name : Create a logical device cdot65.apstra.design : # define how to connect to Apstra server server : apstra.dmz.home port : 443 validate_certs : False api_token : \"{{ api_token }}\" # define design element (a new logical device) type : \"logical-devices\" display_name : \"cool-switch-vendor\" panels : - panel_layout : # rack unit height and width row_count : 1 column_count : 12 port_indexing : # top to bottom, left to right, start with number 1 order : \"T-B, L-R\" schema : \"absolute\" start_index : 1 port_groups : # 12 interfaces, all capable of a leaf role with 10GbE - count : 12 roles : - leaf speed : value : 10 unit : \"G\" # state whether you want to create or delete this resource state : present Options If you'd like to see the options available for you within the module, have a look at the data model provided below. Option Type Description access_switches list standby api_token string our API token to authenticate with Apstra description string standby device_profile_id string standby display_name int standby id string standby interfaces list standby label string standby leafs list standby logical_devices list standby logical_device_id str standby name str standby panels dict standby port int standby server str standby servers list standby state str standby design_template dict standby type str standby validate_certs bool standby Data Model We can also get insight on all available options, and their expected input types, by looking at the module's data model. @staticmethod def design_spec (): return dict ( access_switches = dict ( required = False , type = 'list' , elements = 'str' ), api_token = dict ( required = True , fallback = ( env_fallback , [ 'APSTRA_API_TOKEN' , 'API_TOKEN' ] ), no_log = True , type = 'str' ), description = dict ( required = False , type = 'str' ), device_profile_id = dict ( required = False , type = 'str' ), display_name = dict ( required = True , fallback = ( env_fallback , [ 'APSTRA_USERNAME' , 'USERNAME' ] ), type = 'str' ), id = dict ( required = False , type = 'str' ), interfaces = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( mapping = dict ( required = True , type = 'list' , elements = 'int' ), name = dict ( required = True , type = 'str' , ), position = dict ( required = True , type = 'int' , ), roles = dict ( required = True , type = 'list' , elements = 'str' ), setting = dict ( required = True , type = 'dict' , options = dict ( param = dict ( required = False , type = 'str' ), ) ), speed = dict ( required = True , type = 'dict' , options = dict ( unit = dict ( required = False , type = 'str' ), value = dict ( required = False , type = 'int' ), ) ), state = dict ( required = True , type = 'str' , ), ), ), label = dict ( required = False , type = 'str' ), leafs = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( external_router_facing = dict ( required = True , type = 'bool' , ), external_router_links = dict ( required = True , type = 'list' , elements = 'str' ), label = dict ( required = False , type = 'str' , ), leaf_leaf_l3_link_count = dict ( required = False , type = 'int' , ), leaf_leaf_l3_link_port_channel_id = dict ( required = False , type = 'int' , ), leaf_leaf_l3_link_speed = dict ( required = False , type = 'str' , ), leaf_leaf_link_count = dict ( required = False , type = 'int' , ), leaf_leaf_link_port_channel_id = dict ( required = False , type = 'int' , ), leaf_leaf_link_speed = dict ( required = False , type = 'str' , ), link_per_spine_count = dict ( required = False , type = 'int' , ), link_per_spine_speed = dict ( required = True , type = 'dict' , options = dict ( unit = dict ( required = False , type = 'str' ), value = dict ( required = False , type = 'int' ) ) ), logical_device = dict ( required = False , type = 'str' , ), redundancy_protocol = dict ( required = False , type = 'str' , ), ), ), logical_devices = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( display_name = dict ( required = True , type = 'str' , ), id = dict ( required = True , type = 'str' , ), panels = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( panel_layout = dict ( required = True , type = 'dict' , options = dict ( row_count = dict ( required = False , type = 'int' ), column_count = dict ( required = False , type = 'int' ), ) ), port_indexing = dict ( required = True , type = 'dict' , options = dict ( order = dict ( required = False , type = 'str' ), start_index = dict ( required = False , type = 'int' ), schema = dict ( required = False , type = 'str' ), ) ), port_groups = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( count = dict ( required = False , type = 'int' ), roles = dict ( required = False , type = 'list' , elements = 'str' ), speed = dict ( required = True , type = 'dict' , options = dict ( unit = dict ( required = False , type = 'str' ), value = dict ( required = False , type = 'int' ), ) ), ), ), ), ), ), ), logical_device_id = dict ( required = False , type = 'str' ), name = dict ( required = False , type = 'str' ), panels = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( panel_layout = dict ( required = True , type = 'dict' , options = dict ( row_count = dict ( required = False , type = 'int' ), column_count = dict ( required = False , type = 'int' ), ) ), port_indexing = dict ( required = True , type = 'dict' , options = dict ( order = dict ( required = False , type = 'str' ), schema = dict ( required = False , type = 'str' ), start_index = dict ( required = False , type = 'int' ), ), ), port_groups = dict ( required = True , type = 'list' , elements = 'dict' , options = dict ( count = dict ( required = False , type = 'int' ), roles = dict ( required = False , type = 'list' , elements = 'str' ), speed = dict ( required = False , type = 'dict' , options = dict ( value = dict ( required = False , type = 'int' ), unit = dict ( required = False , type = 'str' ), ), ), ), ), ), ), port = dict ( required = False , type = 'int' ), server = dict ( required = False , type = 'str' ), servers = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( connectivity_type = dict ( required = True , type = 'str' , ), count = dict ( required = True , type = 'int' , ), label = dict ( required = True , type = 'str' , ), logical_device = dict ( required = True , type = 'str' , ), ip_version = dict ( required = True , type = 'str' , ), port_channel_id_min = dict ( required = True , type = 'int' , ), port_channel_id_max = dict ( required = True , type = 'int' , ), links = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( attachment_type = dict ( required = False , type = 'str' ), label = dict ( required = False , type = 'str' ), lag_mode = dict ( required = False , type = 'str' ), leaf_peer = dict ( required = False , type = 'str' ), link_per_switch_count = dict ( required = False , type = 'int' ), link_speed = dict ( required = True , type = 'dict' , options = dict ( unit = dict ( required = False , type = 'str' ), value = dict ( required = False , type = 'int' ), ) ), target_switch_label = dict ( required = False , type = 'str' ), ), ), ), ), state = dict ( required = True , choices = [ 'absent' , 'present' ], type = 'str' ), design_template = dict ( required = False , type = 'dict' , options = dict ( asn_allocation_policy = dict ( required = False , type = 'dict' , options = dict ( spine_asn_scheme = dict ( required = False , type = 'str' ) ) ), dhcp_service_intent = dict ( required = False , type = 'dict' , options = dict ( active = dict ( required = False , type = 'bool' ) ) ), display_name = dict ( required = True , type = 'str' ), external_routing_policy = dict ( required = False , type = 'dict' , options = dict ( export_policy = dict ( required = False , type = 'dict' , options = dict ( all_routes = dict ( required = False , type = 'bool' ), l2edge_subnets = dict ( required = False , type = 'bool' ), l3edge_server_links = dict ( required = False , type = 'bool' ), loopbacks = dict ( required = False , type = 'bool' ), spine_leaf_links = dict ( required = False , type = 'bool' ), ) ), import_policy = dict ( required = False , type = 'str' ) ) ), fabric_addressing_policy = dict ( required = False , type = 'dict' , options = dict ( spine_leaf_links = dict ( required = False , type = 'str' ) ) ), rack_type_counts = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( count = dict ( required = False , type = 'int' ), rack_type_id = dict ( required = False , type = 'str' ), ) ), rack_types = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( access_switches = dict ( required = False , type = 'list' , elements = 'str' ), description = dict ( required = False , type = 'str' ), display_name = dict ( required = False , type = 'str' ), id = dict ( required = False , type = 'str' ), leafs = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( external_router_facing = dict ( required = False , type = 'bool' ), external_router_links = dict ( required = False , type = 'list' , elements = 'str' ), label = dict ( required = False , type = 'str' ), leaf_leaf_l3_link_count = dict ( required = False , type = 'int' ), leaf_leaf_l3_link_port_channel_id = dict ( required = False , type = 'int' ), leaf_leaf_l3_link_speed = dict ( required = False , type = 'str' ), leaf_leaf_link_count = dict ( required = False , type = 'int' ), leaf_leaf_link_port_channel_id = dict ( required = False , type = 'int' ), leaf_leaf_link_speed = dict ( required = False , type = 'str' ), link_per_spine_count = dict ( required = False , type = 'int' ), link_per_spine_speed = dict ( required = False , type = 'dict' , options = dict ( unit = dict ( type = 'str' , required = False ), value = dict ( type = 'int' , required = False ) ) ), logical_device = dict ( required = True , type = 'str' ), redundancy_protocol = dict ( required = False , type = 'str' ), ) ), logical_devices = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( display_name = dict ( required = True , type = 'str' ), id = dict ( required = True , type = 'str' ), panels = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( panel_layout = dict ( required = False , type = 'dict' , options = dict ( column_count = dict ( required = False , type = 'int' ), row_count = dict ( required = False , type = 'int' ) ) ), port_groups = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( count = dict ( required = False , type = 'int' ), roles = dict ( required = False , type = 'list' , elements = 'str' ), speed = dict ( required = False , type = 'dict' , options = dict ( unit = dict ( required = False , type = 'str' ), value = dict ( required = False , type = 'int' ), ) ), ) ), port_indexing = dict ( required = True , type = 'dict' , options = dict ( order = dict ( required = True , type = 'str' ), schema = dict ( required = True , type = 'str' ), start_index = dict ( required = True , type = 'int' ), ) ) ) ) ) ), servers = dict ( required = True , type = 'list' , elements = 'dict' , options = dict ( connectivity_type = dict ( type = 'str' , required = True ), count = dict ( type = 'int' , required = True ), ip_version = dict ( type = 'str' , required = True ), label = dict ( type = 'str' , required = True ), links = dict ( required = True , type = 'list' , elements = 'dict' , options = dict ( attachment_type = dict ( type = 'str' , required = True ), label = dict ( type = 'str' , required = True ), lag_mode = dict ( type = 'str' , required = False ), link_per_switch_count = dict ( type = 'int' , required = False ), link_speed = dict ( required = True , type = 'dict' , options = dict ( unit = dict ( type = 'str' , required = False ), value = dict ( type = 'int' , required = False ) ) ), target_switch_label = dict ( type = 'str' , required = True ) ) ), logical_device = dict ( type = 'str' , required = True ), port_channel_id_max = dict ( type = 'int' , required = False ), port_channel_id_min = dict ( type = 'int' , required = False ) ) ) ) ), spine = dict ( required = True , type = 'dict' , options = dict ( count = dict ( required = True , type = 'int' ), external_link_count = dict ( required = True , type = 'int' ), external_link_speed = dict ( required = True , type = 'str' ), link_per_superspine_count = dict ( required = True , type = 'int' ), link_per_superspine_speed = dict ( required = True , type = 'str' ), logical_device = dict ( required = True , type = 'dict' , options = dict ( display_name = dict ( required = True , type = 'str' ), id = dict ( required = True , type = 'str' ), panels = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( panel_layout = dict ( required = False , type = 'dict' , options = dict ( column_count = dict ( required = False , type = 'int' ), row_count = dict ( required = False , type = 'int' ) ) ), port_groups = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( count = dict ( required = False , type = 'int' ), roles = dict ( required = False , type = 'list' , elements = 'str' ), speed = dict ( required = False , type = 'dict' , options = dict ( unit = dict ( required = False , type = 'str' ), value = dict ( required = False , type = 'int' ) ) ) ) ), port_indexing = dict ( required = False , type = 'dict' , options = dict ( order = dict ( type = 'str' , required = False ), schema = dict ( type = 'str' , required = False ), start_index = dict ( type = 'int' , required = False ) ) ) ) ) ) ) ) ), type = dict ( required = True , type = 'str' ), virtual_network_policy = dict ( required = True , type = 'dict' , options = dict ( overlay_control_protocol = dict ( required = True , type = 'str' ) ) ) ) ), type = dict ( required = True , choices = [ 'logical-devices' , 'interface-maps' , 'rack-types' , 'templates' ], type = 'str' ), validate_certs = dict ( type = 'bool' , required = False , default = False ), )","title":"Build"},{"location":"docs/terraform/build/ike/#overview","text":"The cdot65.apstra.design module will allow you to manage your design elements within Apstra. Feature set as of version 0.0.14: manage Logical Devices, Rack Types, Templates, Intereface Mapping idempotent Suported Resources: Design Element How to specify within Ansible module parameter \"type\" Interface Mapping interface-maps Logical Device logical-devices Rack Types rack-types Templates templates","title":"\ud83d\udccc Overview"},{"location":"docs/terraform/build/ike/#example","text":"- name : Create a logical device cdot65.apstra.design : # define how to connect to Apstra server server : apstra.dmz.home port : 443 validate_certs : False api_token : \"{{ api_token }}\" # define design element (a new logical device) type : \"logical-devices\" display_name : \"cool-switch-vendor\" panels : - panel_layout : # rack unit height and width row_count : 1 column_count : 12 port_indexing : # top to bottom, left to right, start with number 1 order : \"T-B, L-R\" schema : \"absolute\" start_index : 1 port_groups : # 12 interfaces, all capable of a leaf role with 10GbE - count : 12 roles : - leaf speed : value : 10 unit : \"G\" # state whether you want to create or delete this resource state : present","title":"Example"},{"location":"docs/terraform/build/ike/#options","text":"If you'd like to see the options available for you within the module, have a look at the data model provided below. Option Type Description access_switches list standby api_token string our API token to authenticate with Apstra description string standby device_profile_id string standby display_name int standby id string standby interfaces list standby label string standby leafs list standby logical_devices list standby logical_device_id str standby name str standby panels dict standby port int standby server str standby servers list standby state str standby design_template dict standby type str standby validate_certs bool standby","title":"Options"},{"location":"docs/terraform/build/ike/#data-model","text":"We can also get insight on all available options, and their expected input types, by looking at the module's data model. @staticmethod def design_spec (): return dict ( access_switches = dict ( required = False , type = 'list' , elements = 'str' ), api_token = dict ( required = True , fallback = ( env_fallback , [ 'APSTRA_API_TOKEN' , 'API_TOKEN' ] ), no_log = True , type = 'str' ), description = dict ( required = False , type = 'str' ), device_profile_id = dict ( required = False , type = 'str' ), display_name = dict ( required = True , fallback = ( env_fallback , [ 'APSTRA_USERNAME' , 'USERNAME' ] ), type = 'str' ), id = dict ( required = False , type = 'str' ), interfaces = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( mapping = dict ( required = True , type = 'list' , elements = 'int' ), name = dict ( required = True , type = 'str' , ), position = dict ( required = True , type = 'int' , ), roles = dict ( required = True , type = 'list' , elements = 'str' ), setting = dict ( required = True , type = 'dict' , options = dict ( param = dict ( required = False , type = 'str' ), ) ), speed = dict ( required = True , type = 'dict' , options = dict ( unit = dict ( required = False , type = 'str' ), value = dict ( required = False , type = 'int' ), ) ), state = dict ( required = True , type = 'str' , ), ), ), label = dict ( required = False , type = 'str' ), leafs = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( external_router_facing = dict ( required = True , type = 'bool' , ), external_router_links = dict ( required = True , type = 'list' , elements = 'str' ), label = dict ( required = False , type = 'str' , ), leaf_leaf_l3_link_count = dict ( required = False , type = 'int' , ), leaf_leaf_l3_link_port_channel_id = dict ( required = False , type = 'int' , ), leaf_leaf_l3_link_speed = dict ( required = False , type = 'str' , ), leaf_leaf_link_count = dict ( required = False , type = 'int' , ), leaf_leaf_link_port_channel_id = dict ( required = False , type = 'int' , ), leaf_leaf_link_speed = dict ( required = False , type = 'str' , ), link_per_spine_count = dict ( required = False , type = 'int' , ), link_per_spine_speed = dict ( required = True , type = 'dict' , options = dict ( unit = dict ( required = False , type = 'str' ), value = dict ( required = False , type = 'int' ) ) ), logical_device = dict ( required = False , type = 'str' , ), redundancy_protocol = dict ( required = False , type = 'str' , ), ), ), logical_devices = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( display_name = dict ( required = True , type = 'str' , ), id = dict ( required = True , type = 'str' , ), panels = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( panel_layout = dict ( required = True , type = 'dict' , options = dict ( row_count = dict ( required = False , type = 'int' ), column_count = dict ( required = False , type = 'int' ), ) ), port_indexing = dict ( required = True , type = 'dict' , options = dict ( order = dict ( required = False , type = 'str' ), start_index = dict ( required = False , type = 'int' ), schema = dict ( required = False , type = 'str' ), ) ), port_groups = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( count = dict ( required = False , type = 'int' ), roles = dict ( required = False , type = 'list' , elements = 'str' ), speed = dict ( required = True , type = 'dict' , options = dict ( unit = dict ( required = False , type = 'str' ), value = dict ( required = False , type = 'int' ), ) ), ), ), ), ), ), ), logical_device_id = dict ( required = False , type = 'str' ), name = dict ( required = False , type = 'str' ), panels = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( panel_layout = dict ( required = True , type = 'dict' , options = dict ( row_count = dict ( required = False , type = 'int' ), column_count = dict ( required = False , type = 'int' ), ) ), port_indexing = dict ( required = True , type = 'dict' , options = dict ( order = dict ( required = False , type = 'str' ), schema = dict ( required = False , type = 'str' ), start_index = dict ( required = False , type = 'int' ), ), ), port_groups = dict ( required = True , type = 'list' , elements = 'dict' , options = dict ( count = dict ( required = False , type = 'int' ), roles = dict ( required = False , type = 'list' , elements = 'str' ), speed = dict ( required = False , type = 'dict' , options = dict ( value = dict ( required = False , type = 'int' ), unit = dict ( required = False , type = 'str' ), ), ), ), ), ), ), port = dict ( required = False , type = 'int' ), server = dict ( required = False , type = 'str' ), servers = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( connectivity_type = dict ( required = True , type = 'str' , ), count = dict ( required = True , type = 'int' , ), label = dict ( required = True , type = 'str' , ), logical_device = dict ( required = True , type = 'str' , ), ip_version = dict ( required = True , type = 'str' , ), port_channel_id_min = dict ( required = True , type = 'int' , ), port_channel_id_max = dict ( required = True , type = 'int' , ), links = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( attachment_type = dict ( required = False , type = 'str' ), label = dict ( required = False , type = 'str' ), lag_mode = dict ( required = False , type = 'str' ), leaf_peer = dict ( required = False , type = 'str' ), link_per_switch_count = dict ( required = False , type = 'int' ), link_speed = dict ( required = True , type = 'dict' , options = dict ( unit = dict ( required = False , type = 'str' ), value = dict ( required = False , type = 'int' ), ) ), target_switch_label = dict ( required = False , type = 'str' ), ), ), ), ), state = dict ( required = True , choices = [ 'absent' , 'present' ], type = 'str' ), design_template = dict ( required = False , type = 'dict' , options = dict ( asn_allocation_policy = dict ( required = False , type = 'dict' , options = dict ( spine_asn_scheme = dict ( required = False , type = 'str' ) ) ), dhcp_service_intent = dict ( required = False , type = 'dict' , options = dict ( active = dict ( required = False , type = 'bool' ) ) ), display_name = dict ( required = True , type = 'str' ), external_routing_policy = dict ( required = False , type = 'dict' , options = dict ( export_policy = dict ( required = False , type = 'dict' , options = dict ( all_routes = dict ( required = False , type = 'bool' ), l2edge_subnets = dict ( required = False , type = 'bool' ), l3edge_server_links = dict ( required = False , type = 'bool' ), loopbacks = dict ( required = False , type = 'bool' ), spine_leaf_links = dict ( required = False , type = 'bool' ), ) ), import_policy = dict ( required = False , type = 'str' ) ) ), fabric_addressing_policy = dict ( required = False , type = 'dict' , options = dict ( spine_leaf_links = dict ( required = False , type = 'str' ) ) ), rack_type_counts = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( count = dict ( required = False , type = 'int' ), rack_type_id = dict ( required = False , type = 'str' ), ) ), rack_types = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( access_switches = dict ( required = False , type = 'list' , elements = 'str' ), description = dict ( required = False , type = 'str' ), display_name = dict ( required = False , type = 'str' ), id = dict ( required = False , type = 'str' ), leafs = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( external_router_facing = dict ( required = False , type = 'bool' ), external_router_links = dict ( required = False , type = 'list' , elements = 'str' ), label = dict ( required = False , type = 'str' ), leaf_leaf_l3_link_count = dict ( required = False , type = 'int' ), leaf_leaf_l3_link_port_channel_id = dict ( required = False , type = 'int' ), leaf_leaf_l3_link_speed = dict ( required = False , type = 'str' ), leaf_leaf_link_count = dict ( required = False , type = 'int' ), leaf_leaf_link_port_channel_id = dict ( required = False , type = 'int' ), leaf_leaf_link_speed = dict ( required = False , type = 'str' ), link_per_spine_count = dict ( required = False , type = 'int' ), link_per_spine_speed = dict ( required = False , type = 'dict' , options = dict ( unit = dict ( type = 'str' , required = False ), value = dict ( type = 'int' , required = False ) ) ), logical_device = dict ( required = True , type = 'str' ), redundancy_protocol = dict ( required = False , type = 'str' ), ) ), logical_devices = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( display_name = dict ( required = True , type = 'str' ), id = dict ( required = True , type = 'str' ), panels = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( panel_layout = dict ( required = False , type = 'dict' , options = dict ( column_count = dict ( required = False , type = 'int' ), row_count = dict ( required = False , type = 'int' ) ) ), port_groups = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( count = dict ( required = False , type = 'int' ), roles = dict ( required = False , type = 'list' , elements = 'str' ), speed = dict ( required = False , type = 'dict' , options = dict ( unit = dict ( required = False , type = 'str' ), value = dict ( required = False , type = 'int' ), ) ), ) ), port_indexing = dict ( required = True , type = 'dict' , options = dict ( order = dict ( required = True , type = 'str' ), schema = dict ( required = True , type = 'str' ), start_index = dict ( required = True , type = 'int' ), ) ) ) ) ) ), servers = dict ( required = True , type = 'list' , elements = 'dict' , options = dict ( connectivity_type = dict ( type = 'str' , required = True ), count = dict ( type = 'int' , required = True ), ip_version = dict ( type = 'str' , required = True ), label = dict ( type = 'str' , required = True ), links = dict ( required = True , type = 'list' , elements = 'dict' , options = dict ( attachment_type = dict ( type = 'str' , required = True ), label = dict ( type = 'str' , required = True ), lag_mode = dict ( type = 'str' , required = False ), link_per_switch_count = dict ( type = 'int' , required = False ), link_speed = dict ( required = True , type = 'dict' , options = dict ( unit = dict ( type = 'str' , required = False ), value = dict ( type = 'int' , required = False ) ) ), target_switch_label = dict ( type = 'str' , required = True ) ) ), logical_device = dict ( type = 'str' , required = True ), port_channel_id_max = dict ( type = 'int' , required = False ), port_channel_id_min = dict ( type = 'int' , required = False ) ) ) ) ), spine = dict ( required = True , type = 'dict' , options = dict ( count = dict ( required = True , type = 'int' ), external_link_count = dict ( required = True , type = 'int' ), external_link_speed = dict ( required = True , type = 'str' ), link_per_superspine_count = dict ( required = True , type = 'int' ), link_per_superspine_speed = dict ( required = True , type = 'str' ), logical_device = dict ( required = True , type = 'dict' , options = dict ( display_name = dict ( required = True , type = 'str' ), id = dict ( required = True , type = 'str' ), panels = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( panel_layout = dict ( required = False , type = 'dict' , options = dict ( column_count = dict ( required = False , type = 'int' ), row_count = dict ( required = False , type = 'int' ) ) ), port_groups = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( count = dict ( required = False , type = 'int' ), roles = dict ( required = False , type = 'list' , elements = 'str' ), speed = dict ( required = False , type = 'dict' , options = dict ( unit = dict ( required = False , type = 'str' ), value = dict ( required = False , type = 'int' ) ) ) ) ), port_indexing = dict ( required = False , type = 'dict' , options = dict ( order = dict ( type = 'str' , required = False ), schema = dict ( type = 'str' , required = False ), start_index = dict ( type = 'int' , required = False ) ) ) ) ) ) ) ) ), type = dict ( required = True , type = 'str' ), virtual_network_policy = dict ( required = True , type = 'dict' , options = dict ( overlay_control_protocol = dict ( required = True , type = 'str' ) ) ) ) ), type = dict ( required = True , choices = [ 'logical-devices' , 'interface-maps' , 'rack-types' , 'templates' ], type = 'str' ), validate_certs = dict ( type = 'bool' , required = False , default = False ), )","title":"Data Model"},{"location":"docs/terraform/build/ipsec/","text":"\ud83d\udccc Overview The cdot65.apstra.resources module will allow you to manage the configuration of your Blueprint within Apstra. Feature set as of version 0.0.7: manage all resources supports tagging idempotent Suported Resources: Resource Type Ansible module parameter \"type\" ASN Pool asn-pools IPv4 Pool ip-pools IPv6 Pool ipv6-pools VLAN Pool vlan-pools VNI Pool vni-pools Example Here is a basic example of using the module to manage your resources within in Apstra - name : Create an IP Pool Resource with two prefixes cdot65.apstra.resources : # define server connectivity options server : apstra.dmz.home port : 443 validate_certs : False api_token : \"{{ api_token }}\" # define resource allocations display_name : \"Windows Servers\" tags : [] type : \"ip-pools\" subnets : - \"100.1.1.0/24\" - \"100.1.2.0/24\" # state whether you want to create or delete this resource state : present # store the output of our task as a new variable to debug later register : windows_servers_ippool Options If you'd like to see the options available for you within the module, have a look at the data model provided below. Option Type Description api_token string our API token to authenticate with Apstra address string standby asn int standby display_name string standby ipv6_address string standby port int standby ranges list standby subnets list standby server string Apstra's DNS hostname or IP address state string determine whether to create or delete resource tags list standby type string standby validate_certs bool enable or disable SSL certificate validation Data Model We can also get insight on all available options, and their expected input types, by looking at the module's data model. @staticmethod def resources_spec (): return dict ( address = dict ( required = False , type = 'str' ), asn = dict ( required = False , type = 'int' ), api_token = dict ( required = True , fallback = ( env_fallback , [ 'APSTRA_API_TOKEN' , 'APSTRA_API_TOKEN' , 'API_TOKEN' ]), no_log = True , type = 'str' ), display_name = dict ( required = True , fallback = ( env_fallback , [ 'APSTRA_USERNAME' , 'APSTRA_USERNAME' , 'USERNAME' ]), type = 'str' ), ipv6_address = dict ( required = False , type = 'str' ), port = dict ( required = True , type = 'int' ), ranges = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( first = dict ( required = True , type = 'int' ), last = dict ( required = True , type = 'int' ), ), ), server = dict ( required = False , type = 'str' ), state = dict ( required = False , choices = [ 'absent' , 'present' ], type = 'str' ), subnets = dict ( required = False , type = 'list' , elements = 'str' ), tags = dict ( required = False , type = 'list' , elements = 'str' ), type = dict ( required = True , choices = [ 'asn-pools' , 'external-routers' , 'ip-pools' , 'ipv6-pools' , 'vlan-pools' , 'vni-pools' ], type = 'str' ), validate_certs = dict ( type = 'bool' , required = False , default = False ), )","title":"Build"},{"location":"docs/terraform/build/ipsec/#overview","text":"The cdot65.apstra.resources module will allow you to manage the configuration of your Blueprint within Apstra. Feature set as of version 0.0.7: manage all resources supports tagging idempotent Suported Resources: Resource Type Ansible module parameter \"type\" ASN Pool asn-pools IPv4 Pool ip-pools IPv6 Pool ipv6-pools VLAN Pool vlan-pools VNI Pool vni-pools","title":"\ud83d\udccc Overview"},{"location":"docs/terraform/build/ipsec/#example","text":"Here is a basic example of using the module to manage your resources within in Apstra - name : Create an IP Pool Resource with two prefixes cdot65.apstra.resources : # define server connectivity options server : apstra.dmz.home port : 443 validate_certs : False api_token : \"{{ api_token }}\" # define resource allocations display_name : \"Windows Servers\" tags : [] type : \"ip-pools\" subnets : - \"100.1.1.0/24\" - \"100.1.2.0/24\" # state whether you want to create or delete this resource state : present # store the output of our task as a new variable to debug later register : windows_servers_ippool","title":"Example"},{"location":"docs/terraform/build/ipsec/#options","text":"If you'd like to see the options available for you within the module, have a look at the data model provided below. Option Type Description api_token string our API token to authenticate with Apstra address string standby asn int standby display_name string standby ipv6_address string standby port int standby ranges list standby subnets list standby server string Apstra's DNS hostname or IP address state string determine whether to create or delete resource tags list standby type string standby validate_certs bool enable or disable SSL certificate validation","title":"Options"},{"location":"docs/terraform/build/ipsec/#data-model","text":"We can also get insight on all available options, and their expected input types, by looking at the module's data model. @staticmethod def resources_spec (): return dict ( address = dict ( required = False , type = 'str' ), asn = dict ( required = False , type = 'int' ), api_token = dict ( required = True , fallback = ( env_fallback , [ 'APSTRA_API_TOKEN' , 'APSTRA_API_TOKEN' , 'API_TOKEN' ]), no_log = True , type = 'str' ), display_name = dict ( required = True , fallback = ( env_fallback , [ 'APSTRA_USERNAME' , 'APSTRA_USERNAME' , 'USERNAME' ]), type = 'str' ), ipv6_address = dict ( required = False , type = 'str' ), port = dict ( required = True , type = 'int' ), ranges = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( first = dict ( required = True , type = 'int' ), last = dict ( required = True , type = 'int' ), ), ), server = dict ( required = False , type = 'str' ), state = dict ( required = False , choices = [ 'absent' , 'present' ], type = 'str' ), subnets = dict ( required = False , type = 'list' , elements = 'str' ), tags = dict ( required = False , type = 'list' , elements = 'str' ), type = dict ( required = True , choices = [ 'asn-pools' , 'external-routers' , 'ip-pools' , 'ipv6-pools' , 'vlan-pools' , 'vni-pools' ], type = 'str' ), validate_certs = dict ( type = 'bool' , required = False , default = False ), )","title":"Data Model"},{"location":"docs/terraform/providers/addressbook/","text":"\ud83d\udccc Overview The cdot65.apstra.blueprint module will allow you to manage the configuration of your Blueprint within Apstra. Feature set as of version 0.0.15: manage Blueprints idempotent Example Here is a basic example of using the module to manage your blueprint's configuration in Apstra - name : \"### CREATE BLUEPRINT cicd_template\" cdot65.apstra.blueprint : # define apstra server parameters server : \"apstra.dmz.home\" api_token : \"{{ api_token }}\" # define blueprint parameters design : \"two_stage_l3clos\" init_type : \"template_reference\" template_id : \"{{ templates['data']['id'] }}\" label : \"cicd_template\" # define whether to create or delete the blueprint state : present Options If you'd like to see the options available for you within the module, have a look at the data model provided below. Option Type Description api_token string our API token to authenticate with Apstra design string reference to our Design's UUID label string associate a label with our blueprint port int port number server string Apstra's DNS hostname or IP address state string determine whether to create or delete blueprint template_id string reference to our Template's UUID validate_certs bool enable or disable SSL certificate validation Data Model We can also get insight on all available options, and their expected input types, by looking at the module's data model. @staticmethod def blueprint_spec (): return dict ( api_token = dict ( required = True , fallback = ( env_fallback , [ 'APSTRA_API_TOKEN' , 'APSTRA_API_TOKEN' , 'API_TOKEN' ]), no_log = True , type = 'str' ), design = dict ( required = False , type = 'str' ), init_type = dict ( required = False , type = 'str' ), label = dict ( required = True , type = 'str' ), template_id = dict ( required = False , type = 'str' ), port = dict ( required = False , type = 'int' ), server = dict ( required = False , type = 'str' ), state = dict ( required = True , choices = [ 'absent' , 'present' ], type = 'str' ), validate_certs = dict ( type = 'bool' , required = False , default = False ), )","title":"Provider"},{"location":"docs/terraform/providers/addressbook/#overview","text":"The cdot65.apstra.blueprint module will allow you to manage the configuration of your Blueprint within Apstra. Feature set as of version 0.0.15: manage Blueprints idempotent","title":"\ud83d\udccc Overview"},{"location":"docs/terraform/providers/addressbook/#example","text":"Here is a basic example of using the module to manage your blueprint's configuration in Apstra - name : \"### CREATE BLUEPRINT cicd_template\" cdot65.apstra.blueprint : # define apstra server parameters server : \"apstra.dmz.home\" api_token : \"{{ api_token }}\" # define blueprint parameters design : \"two_stage_l3clos\" init_type : \"template_reference\" template_id : \"{{ templates['data']['id'] }}\" label : \"cicd_template\" # define whether to create or delete the blueprint state : present","title":"Example"},{"location":"docs/terraform/providers/addressbook/#options","text":"If you'd like to see the options available for you within the module, have a look at the data model provided below. Option Type Description api_token string our API token to authenticate with Apstra design string reference to our Design's UUID label string associate a label with our blueprint port int port number server string Apstra's DNS hostname or IP address state string determine whether to create or delete blueprint template_id string reference to our Template's UUID validate_certs bool enable or disable SSL certificate validation","title":"Options"},{"location":"docs/terraform/providers/addressbook/#data-model","text":"We can also get insight on all available options, and their expected input types, by looking at the module's data model. @staticmethod def blueprint_spec (): return dict ( api_token = dict ( required = True , fallback = ( env_fallback , [ 'APSTRA_API_TOKEN' , 'APSTRA_API_TOKEN' , 'API_TOKEN' ]), no_log = True , type = 'str' ), design = dict ( required = False , type = 'str' ), init_type = dict ( required = False , type = 'str' ), label = dict ( required = True , type = 'str' ), template_id = dict ( required = False , type = 'str' ), port = dict ( required = False , type = 'int' ), server = dict ( required = False , type = 'str' ), state = dict ( required = True , choices = [ 'absent' , 'present' ], type = 'str' ), validate_certs = dict ( type = 'bool' , required = False , default = False ), )","title":"Data Model"},{"location":"docs/terraform/providers/ike/","text":"\ud83d\udccc Overview The cdot65.apstra.design module will allow you to manage your design elements within Apstra. Feature set as of version 0.0.14: manage Logical Devices, Rack Types, Templates, Intereface Mapping idempotent Suported Resources: Design Element How to specify within Ansible module parameter \"type\" Interface Mapping interface-maps Logical Device logical-devices Rack Types rack-types Templates templates Example - name : Create a logical device cdot65.apstra.design : # define how to connect to Apstra server server : apstra.dmz.home port : 443 validate_certs : False api_token : \"{{ api_token }}\" # define design element (a new logical device) type : \"logical-devices\" display_name : \"cool-switch-vendor\" panels : - panel_layout : # rack unit height and width row_count : 1 column_count : 12 port_indexing : # top to bottom, left to right, start with number 1 order : \"T-B, L-R\" schema : \"absolute\" start_index : 1 port_groups : # 12 interfaces, all capable of a leaf role with 10GbE - count : 12 roles : - leaf speed : value : 10 unit : \"G\" # state whether you want to create or delete this resource state : present Options If you'd like to see the options available for you within the module, have a look at the data model provided below. Option Type Description access_switches list standby api_token string our API token to authenticate with Apstra description string standby device_profile_id string standby display_name int standby id string standby interfaces list standby label string standby leafs list standby logical_devices list standby logical_device_id str standby name str standby panels dict standby port int standby server str standby servers list standby state str standby design_template dict standby type str standby validate_certs bool standby Data Model We can also get insight on all available options, and their expected input types, by looking at the module's data model. @staticmethod def design_spec (): return dict ( access_switches = dict ( required = False , type = 'list' , elements = 'str' ), api_token = dict ( required = True , fallback = ( env_fallback , [ 'APSTRA_API_TOKEN' , 'API_TOKEN' ] ), no_log = True , type = 'str' ), description = dict ( required = False , type = 'str' ), device_profile_id = dict ( required = False , type = 'str' ), display_name = dict ( required = True , fallback = ( env_fallback , [ 'APSTRA_USERNAME' , 'USERNAME' ] ), type = 'str' ), id = dict ( required = False , type = 'str' ), interfaces = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( mapping = dict ( required = True , type = 'list' , elements = 'int' ), name = dict ( required = True , type = 'str' , ), position = dict ( required = True , type = 'int' , ), roles = dict ( required = True , type = 'list' , elements = 'str' ), setting = dict ( required = True , type = 'dict' , options = dict ( param = dict ( required = False , type = 'str' ), ) ), speed = dict ( required = True , type = 'dict' , options = dict ( unit = dict ( required = False , type = 'str' ), value = dict ( required = False , type = 'int' ), ) ), state = dict ( required = True , type = 'str' , ), ), ), label = dict ( required = False , type = 'str' ), leafs = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( external_router_facing = dict ( required = True , type = 'bool' , ), external_router_links = dict ( required = True , type = 'list' , elements = 'str' ), label = dict ( required = False , type = 'str' , ), leaf_leaf_l3_link_count = dict ( required = False , type = 'int' , ), leaf_leaf_l3_link_port_channel_id = dict ( required = False , type = 'int' , ), leaf_leaf_l3_link_speed = dict ( required = False , type = 'str' , ), leaf_leaf_link_count = dict ( required = False , type = 'int' , ), leaf_leaf_link_port_channel_id = dict ( required = False , type = 'int' , ), leaf_leaf_link_speed = dict ( required = False , type = 'str' , ), link_per_spine_count = dict ( required = False , type = 'int' , ), link_per_spine_speed = dict ( required = True , type = 'dict' , options = dict ( unit = dict ( required = False , type = 'str' ), value = dict ( required = False , type = 'int' ) ) ), logical_device = dict ( required = False , type = 'str' , ), redundancy_protocol = dict ( required = False , type = 'str' , ), ), ), logical_devices = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( display_name = dict ( required = True , type = 'str' , ), id = dict ( required = True , type = 'str' , ), panels = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( panel_layout = dict ( required = True , type = 'dict' , options = dict ( row_count = dict ( required = False , type = 'int' ), column_count = dict ( required = False , type = 'int' ), ) ), port_indexing = dict ( required = True , type = 'dict' , options = dict ( order = dict ( required = False , type = 'str' ), start_index = dict ( required = False , type = 'int' ), schema = dict ( required = False , type = 'str' ), ) ), port_groups = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( count = dict ( required = False , type = 'int' ), roles = dict ( required = False , type = 'list' , elements = 'str' ), speed = dict ( required = True , type = 'dict' , options = dict ( unit = dict ( required = False , type = 'str' ), value = dict ( required = False , type = 'int' ), ) ), ), ), ), ), ), ), logical_device_id = dict ( required = False , type = 'str' ), name = dict ( required = False , type = 'str' ), panels = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( panel_layout = dict ( required = True , type = 'dict' , options = dict ( row_count = dict ( required = False , type = 'int' ), column_count = dict ( required = False , type = 'int' ), ) ), port_indexing = dict ( required = True , type = 'dict' , options = dict ( order = dict ( required = False , type = 'str' ), schema = dict ( required = False , type = 'str' ), start_index = dict ( required = False , type = 'int' ), ), ), port_groups = dict ( required = True , type = 'list' , elements = 'dict' , options = dict ( count = dict ( required = False , type = 'int' ), roles = dict ( required = False , type = 'list' , elements = 'str' ), speed = dict ( required = False , type = 'dict' , options = dict ( value = dict ( required = False , type = 'int' ), unit = dict ( required = False , type = 'str' ), ), ), ), ), ), ), port = dict ( required = False , type = 'int' ), server = dict ( required = False , type = 'str' ), servers = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( connectivity_type = dict ( required = True , type = 'str' , ), count = dict ( required = True , type = 'int' , ), label = dict ( required = True , type = 'str' , ), logical_device = dict ( required = True , type = 'str' , ), ip_version = dict ( required = True , type = 'str' , ), port_channel_id_min = dict ( required = True , type = 'int' , ), port_channel_id_max = dict ( required = True , type = 'int' , ), links = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( attachment_type = dict ( required = False , type = 'str' ), label = dict ( required = False , type = 'str' ), lag_mode = dict ( required = False , type = 'str' ), leaf_peer = dict ( required = False , type = 'str' ), link_per_switch_count = dict ( required = False , type = 'int' ), link_speed = dict ( required = True , type = 'dict' , options = dict ( unit = dict ( required = False , type = 'str' ), value = dict ( required = False , type = 'int' ), ) ), target_switch_label = dict ( required = False , type = 'str' ), ), ), ), ), state = dict ( required = True , choices = [ 'absent' , 'present' ], type = 'str' ), design_template = dict ( required = False , type = 'dict' , options = dict ( asn_allocation_policy = dict ( required = False , type = 'dict' , options = dict ( spine_asn_scheme = dict ( required = False , type = 'str' ) ) ), dhcp_service_intent = dict ( required = False , type = 'dict' , options = dict ( active = dict ( required = False , type = 'bool' ) ) ), display_name = dict ( required = True , type = 'str' ), external_routing_policy = dict ( required = False , type = 'dict' , options = dict ( export_policy = dict ( required = False , type = 'dict' , options = dict ( all_routes = dict ( required = False , type = 'bool' ), l2edge_subnets = dict ( required = False , type = 'bool' ), l3edge_server_links = dict ( required = False , type = 'bool' ), loopbacks = dict ( required = False , type = 'bool' ), spine_leaf_links = dict ( required = False , type = 'bool' ), ) ), import_policy = dict ( required = False , type = 'str' ) ) ), fabric_addressing_policy = dict ( required = False , type = 'dict' , options = dict ( spine_leaf_links = dict ( required = False , type = 'str' ) ) ), rack_type_counts = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( count = dict ( required = False , type = 'int' ), rack_type_id = dict ( required = False , type = 'str' ), ) ), rack_types = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( access_switches = dict ( required = False , type = 'list' , elements = 'str' ), description = dict ( required = False , type = 'str' ), display_name = dict ( required = False , type = 'str' ), id = dict ( required = False , type = 'str' ), leafs = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( external_router_facing = dict ( required = False , type = 'bool' ), external_router_links = dict ( required = False , type = 'list' , elements = 'str' ), label = dict ( required = False , type = 'str' ), leaf_leaf_l3_link_count = dict ( required = False , type = 'int' ), leaf_leaf_l3_link_port_channel_id = dict ( required = False , type = 'int' ), leaf_leaf_l3_link_speed = dict ( required = False , type = 'str' ), leaf_leaf_link_count = dict ( required = False , type = 'int' ), leaf_leaf_link_port_channel_id = dict ( required = False , type = 'int' ), leaf_leaf_link_speed = dict ( required = False , type = 'str' ), link_per_spine_count = dict ( required = False , type = 'int' ), link_per_spine_speed = dict ( required = False , type = 'dict' , options = dict ( unit = dict ( type = 'str' , required = False ), value = dict ( type = 'int' , required = False ) ) ), logical_device = dict ( required = True , type = 'str' ), redundancy_protocol = dict ( required = False , type = 'str' ), ) ), logical_devices = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( display_name = dict ( required = True , type = 'str' ), id = dict ( required = True , type = 'str' ), panels = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( panel_layout = dict ( required = False , type = 'dict' , options = dict ( column_count = dict ( required = False , type = 'int' ), row_count = dict ( required = False , type = 'int' ) ) ), port_groups = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( count = dict ( required = False , type = 'int' ), roles = dict ( required = False , type = 'list' , elements = 'str' ), speed = dict ( required = False , type = 'dict' , options = dict ( unit = dict ( required = False , type = 'str' ), value = dict ( required = False , type = 'int' ), ) ), ) ), port_indexing = dict ( required = True , type = 'dict' , options = dict ( order = dict ( required = True , type = 'str' ), schema = dict ( required = True , type = 'str' ), start_index = dict ( required = True , type = 'int' ), ) ) ) ) ) ), servers = dict ( required = True , type = 'list' , elements = 'dict' , options = dict ( connectivity_type = dict ( type = 'str' , required = True ), count = dict ( type = 'int' , required = True ), ip_version = dict ( type = 'str' , required = True ), label = dict ( type = 'str' , required = True ), links = dict ( required = True , type = 'list' , elements = 'dict' , options = dict ( attachment_type = dict ( type = 'str' , required = True ), label = dict ( type = 'str' , required = True ), lag_mode = dict ( type = 'str' , required = False ), link_per_switch_count = dict ( type = 'int' , required = False ), link_speed = dict ( required = True , type = 'dict' , options = dict ( unit = dict ( type = 'str' , required = False ), value = dict ( type = 'int' , required = False ) ) ), target_switch_label = dict ( type = 'str' , required = True ) ) ), logical_device = dict ( type = 'str' , required = True ), port_channel_id_max = dict ( type = 'int' , required = False ), port_channel_id_min = dict ( type = 'int' , required = False ) ) ) ) ), spine = dict ( required = True , type = 'dict' , options = dict ( count = dict ( required = True , type = 'int' ), external_link_count = dict ( required = True , type = 'int' ), external_link_speed = dict ( required = True , type = 'str' ), link_per_superspine_count = dict ( required = True , type = 'int' ), link_per_superspine_speed = dict ( required = True , type = 'str' ), logical_device = dict ( required = True , type = 'dict' , options = dict ( display_name = dict ( required = True , type = 'str' ), id = dict ( required = True , type = 'str' ), panels = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( panel_layout = dict ( required = False , type = 'dict' , options = dict ( column_count = dict ( required = False , type = 'int' ), row_count = dict ( required = False , type = 'int' ) ) ), port_groups = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( count = dict ( required = False , type = 'int' ), roles = dict ( required = False , type = 'list' , elements = 'str' ), speed = dict ( required = False , type = 'dict' , options = dict ( unit = dict ( required = False , type = 'str' ), value = dict ( required = False , type = 'int' ) ) ) ) ), port_indexing = dict ( required = False , type = 'dict' , options = dict ( order = dict ( type = 'str' , required = False ), schema = dict ( type = 'str' , required = False ), start_index = dict ( type = 'int' , required = False ) ) ) ) ) ) ) ) ), type = dict ( required = True , type = 'str' ), virtual_network_policy = dict ( required = True , type = 'dict' , options = dict ( overlay_control_protocol = dict ( required = True , type = 'str' ) ) ) ) ), type = dict ( required = True , choices = [ 'logical-devices' , 'interface-maps' , 'rack-types' , 'templates' ], type = 'str' ), validate_certs = dict ( type = 'bool' , required = False , default = False ), )","title":"Provider"},{"location":"docs/terraform/providers/ike/#overview","text":"The cdot65.apstra.design module will allow you to manage your design elements within Apstra. Feature set as of version 0.0.14: manage Logical Devices, Rack Types, Templates, Intereface Mapping idempotent Suported Resources: Design Element How to specify within Ansible module parameter \"type\" Interface Mapping interface-maps Logical Device logical-devices Rack Types rack-types Templates templates","title":"\ud83d\udccc Overview"},{"location":"docs/terraform/providers/ike/#example","text":"- name : Create a logical device cdot65.apstra.design : # define how to connect to Apstra server server : apstra.dmz.home port : 443 validate_certs : False api_token : \"{{ api_token }}\" # define design element (a new logical device) type : \"logical-devices\" display_name : \"cool-switch-vendor\" panels : - panel_layout : # rack unit height and width row_count : 1 column_count : 12 port_indexing : # top to bottom, left to right, start with number 1 order : \"T-B, L-R\" schema : \"absolute\" start_index : 1 port_groups : # 12 interfaces, all capable of a leaf role with 10GbE - count : 12 roles : - leaf speed : value : 10 unit : \"G\" # state whether you want to create or delete this resource state : present","title":"Example"},{"location":"docs/terraform/providers/ike/#options","text":"If you'd like to see the options available for you within the module, have a look at the data model provided below. Option Type Description access_switches list standby api_token string our API token to authenticate with Apstra description string standby device_profile_id string standby display_name int standby id string standby interfaces list standby label string standby leafs list standby logical_devices list standby logical_device_id str standby name str standby panels dict standby port int standby server str standby servers list standby state str standby design_template dict standby type str standby validate_certs bool standby","title":"Options"},{"location":"docs/terraform/providers/ike/#data-model","text":"We can also get insight on all available options, and their expected input types, by looking at the module's data model. @staticmethod def design_spec (): return dict ( access_switches = dict ( required = False , type = 'list' , elements = 'str' ), api_token = dict ( required = True , fallback = ( env_fallback , [ 'APSTRA_API_TOKEN' , 'API_TOKEN' ] ), no_log = True , type = 'str' ), description = dict ( required = False , type = 'str' ), device_profile_id = dict ( required = False , type = 'str' ), display_name = dict ( required = True , fallback = ( env_fallback , [ 'APSTRA_USERNAME' , 'USERNAME' ] ), type = 'str' ), id = dict ( required = False , type = 'str' ), interfaces = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( mapping = dict ( required = True , type = 'list' , elements = 'int' ), name = dict ( required = True , type = 'str' , ), position = dict ( required = True , type = 'int' , ), roles = dict ( required = True , type = 'list' , elements = 'str' ), setting = dict ( required = True , type = 'dict' , options = dict ( param = dict ( required = False , type = 'str' ), ) ), speed = dict ( required = True , type = 'dict' , options = dict ( unit = dict ( required = False , type = 'str' ), value = dict ( required = False , type = 'int' ), ) ), state = dict ( required = True , type = 'str' , ), ), ), label = dict ( required = False , type = 'str' ), leafs = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( external_router_facing = dict ( required = True , type = 'bool' , ), external_router_links = dict ( required = True , type = 'list' , elements = 'str' ), label = dict ( required = False , type = 'str' , ), leaf_leaf_l3_link_count = dict ( required = False , type = 'int' , ), leaf_leaf_l3_link_port_channel_id = dict ( required = False , type = 'int' , ), leaf_leaf_l3_link_speed = dict ( required = False , type = 'str' , ), leaf_leaf_link_count = dict ( required = False , type = 'int' , ), leaf_leaf_link_port_channel_id = dict ( required = False , type = 'int' , ), leaf_leaf_link_speed = dict ( required = False , type = 'str' , ), link_per_spine_count = dict ( required = False , type = 'int' , ), link_per_spine_speed = dict ( required = True , type = 'dict' , options = dict ( unit = dict ( required = False , type = 'str' ), value = dict ( required = False , type = 'int' ) ) ), logical_device = dict ( required = False , type = 'str' , ), redundancy_protocol = dict ( required = False , type = 'str' , ), ), ), logical_devices = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( display_name = dict ( required = True , type = 'str' , ), id = dict ( required = True , type = 'str' , ), panels = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( panel_layout = dict ( required = True , type = 'dict' , options = dict ( row_count = dict ( required = False , type = 'int' ), column_count = dict ( required = False , type = 'int' ), ) ), port_indexing = dict ( required = True , type = 'dict' , options = dict ( order = dict ( required = False , type = 'str' ), start_index = dict ( required = False , type = 'int' ), schema = dict ( required = False , type = 'str' ), ) ), port_groups = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( count = dict ( required = False , type = 'int' ), roles = dict ( required = False , type = 'list' , elements = 'str' ), speed = dict ( required = True , type = 'dict' , options = dict ( unit = dict ( required = False , type = 'str' ), value = dict ( required = False , type = 'int' ), ) ), ), ), ), ), ), ), logical_device_id = dict ( required = False , type = 'str' ), name = dict ( required = False , type = 'str' ), panels = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( panel_layout = dict ( required = True , type = 'dict' , options = dict ( row_count = dict ( required = False , type = 'int' ), column_count = dict ( required = False , type = 'int' ), ) ), port_indexing = dict ( required = True , type = 'dict' , options = dict ( order = dict ( required = False , type = 'str' ), schema = dict ( required = False , type = 'str' ), start_index = dict ( required = False , type = 'int' ), ), ), port_groups = dict ( required = True , type = 'list' , elements = 'dict' , options = dict ( count = dict ( required = False , type = 'int' ), roles = dict ( required = False , type = 'list' , elements = 'str' ), speed = dict ( required = False , type = 'dict' , options = dict ( value = dict ( required = False , type = 'int' ), unit = dict ( required = False , type = 'str' ), ), ), ), ), ), ), port = dict ( required = False , type = 'int' ), server = dict ( required = False , type = 'str' ), servers = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( connectivity_type = dict ( required = True , type = 'str' , ), count = dict ( required = True , type = 'int' , ), label = dict ( required = True , type = 'str' , ), logical_device = dict ( required = True , type = 'str' , ), ip_version = dict ( required = True , type = 'str' , ), port_channel_id_min = dict ( required = True , type = 'int' , ), port_channel_id_max = dict ( required = True , type = 'int' , ), links = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( attachment_type = dict ( required = False , type = 'str' ), label = dict ( required = False , type = 'str' ), lag_mode = dict ( required = False , type = 'str' ), leaf_peer = dict ( required = False , type = 'str' ), link_per_switch_count = dict ( required = False , type = 'int' ), link_speed = dict ( required = True , type = 'dict' , options = dict ( unit = dict ( required = False , type = 'str' ), value = dict ( required = False , type = 'int' ), ) ), target_switch_label = dict ( required = False , type = 'str' ), ), ), ), ), state = dict ( required = True , choices = [ 'absent' , 'present' ], type = 'str' ), design_template = dict ( required = False , type = 'dict' , options = dict ( asn_allocation_policy = dict ( required = False , type = 'dict' , options = dict ( spine_asn_scheme = dict ( required = False , type = 'str' ) ) ), dhcp_service_intent = dict ( required = False , type = 'dict' , options = dict ( active = dict ( required = False , type = 'bool' ) ) ), display_name = dict ( required = True , type = 'str' ), external_routing_policy = dict ( required = False , type = 'dict' , options = dict ( export_policy = dict ( required = False , type = 'dict' , options = dict ( all_routes = dict ( required = False , type = 'bool' ), l2edge_subnets = dict ( required = False , type = 'bool' ), l3edge_server_links = dict ( required = False , type = 'bool' ), loopbacks = dict ( required = False , type = 'bool' ), spine_leaf_links = dict ( required = False , type = 'bool' ), ) ), import_policy = dict ( required = False , type = 'str' ) ) ), fabric_addressing_policy = dict ( required = False , type = 'dict' , options = dict ( spine_leaf_links = dict ( required = False , type = 'str' ) ) ), rack_type_counts = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( count = dict ( required = False , type = 'int' ), rack_type_id = dict ( required = False , type = 'str' ), ) ), rack_types = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( access_switches = dict ( required = False , type = 'list' , elements = 'str' ), description = dict ( required = False , type = 'str' ), display_name = dict ( required = False , type = 'str' ), id = dict ( required = False , type = 'str' ), leafs = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( external_router_facing = dict ( required = False , type = 'bool' ), external_router_links = dict ( required = False , type = 'list' , elements = 'str' ), label = dict ( required = False , type = 'str' ), leaf_leaf_l3_link_count = dict ( required = False , type = 'int' ), leaf_leaf_l3_link_port_channel_id = dict ( required = False , type = 'int' ), leaf_leaf_l3_link_speed = dict ( required = False , type = 'str' ), leaf_leaf_link_count = dict ( required = False , type = 'int' ), leaf_leaf_link_port_channel_id = dict ( required = False , type = 'int' ), leaf_leaf_link_speed = dict ( required = False , type = 'str' ), link_per_spine_count = dict ( required = False , type = 'int' ), link_per_spine_speed = dict ( required = False , type = 'dict' , options = dict ( unit = dict ( type = 'str' , required = False ), value = dict ( type = 'int' , required = False ) ) ), logical_device = dict ( required = True , type = 'str' ), redundancy_protocol = dict ( required = False , type = 'str' ), ) ), logical_devices = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( display_name = dict ( required = True , type = 'str' ), id = dict ( required = True , type = 'str' ), panels = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( panel_layout = dict ( required = False , type = 'dict' , options = dict ( column_count = dict ( required = False , type = 'int' ), row_count = dict ( required = False , type = 'int' ) ) ), port_groups = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( count = dict ( required = False , type = 'int' ), roles = dict ( required = False , type = 'list' , elements = 'str' ), speed = dict ( required = False , type = 'dict' , options = dict ( unit = dict ( required = False , type = 'str' ), value = dict ( required = False , type = 'int' ), ) ), ) ), port_indexing = dict ( required = True , type = 'dict' , options = dict ( order = dict ( required = True , type = 'str' ), schema = dict ( required = True , type = 'str' ), start_index = dict ( required = True , type = 'int' ), ) ) ) ) ) ), servers = dict ( required = True , type = 'list' , elements = 'dict' , options = dict ( connectivity_type = dict ( type = 'str' , required = True ), count = dict ( type = 'int' , required = True ), ip_version = dict ( type = 'str' , required = True ), label = dict ( type = 'str' , required = True ), links = dict ( required = True , type = 'list' , elements = 'dict' , options = dict ( attachment_type = dict ( type = 'str' , required = True ), label = dict ( type = 'str' , required = True ), lag_mode = dict ( type = 'str' , required = False ), link_per_switch_count = dict ( type = 'int' , required = False ), link_speed = dict ( required = True , type = 'dict' , options = dict ( unit = dict ( type = 'str' , required = False ), value = dict ( type = 'int' , required = False ) ) ), target_switch_label = dict ( type = 'str' , required = True ) ) ), logical_device = dict ( type = 'str' , required = True ), port_channel_id_max = dict ( type = 'int' , required = False ), port_channel_id_min = dict ( type = 'int' , required = False ) ) ) ) ), spine = dict ( required = True , type = 'dict' , options = dict ( count = dict ( required = True , type = 'int' ), external_link_count = dict ( required = True , type = 'int' ), external_link_speed = dict ( required = True , type = 'str' ), link_per_superspine_count = dict ( required = True , type = 'int' ), link_per_superspine_speed = dict ( required = True , type = 'str' ), logical_device = dict ( required = True , type = 'dict' , options = dict ( display_name = dict ( required = True , type = 'str' ), id = dict ( required = True , type = 'str' ), panels = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( panel_layout = dict ( required = False , type = 'dict' , options = dict ( column_count = dict ( required = False , type = 'int' ), row_count = dict ( required = False , type = 'int' ) ) ), port_groups = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( count = dict ( required = False , type = 'int' ), roles = dict ( required = False , type = 'list' , elements = 'str' ), speed = dict ( required = False , type = 'dict' , options = dict ( unit = dict ( required = False , type = 'str' ), value = dict ( required = False , type = 'int' ) ) ) ) ), port_indexing = dict ( required = False , type = 'dict' , options = dict ( order = dict ( type = 'str' , required = False ), schema = dict ( type = 'str' , required = False ), start_index = dict ( type = 'int' , required = False ) ) ) ) ) ) ) ) ), type = dict ( required = True , type = 'str' ), virtual_network_policy = dict ( required = True , type = 'dict' , options = dict ( overlay_control_protocol = dict ( required = True , type = 'str' ) ) ) ) ), type = dict ( required = True , choices = [ 'logical-devices' , 'interface-maps' , 'rack-types' , 'templates' ], type = 'str' ), validate_certs = dict ( type = 'bool' , required = False , default = False ), )","title":"Data Model"},{"location":"docs/terraform/providers/ipsec/","text":"\ud83d\udccc Overview The cdot65.apstra.resources module will allow you to manage the configuration of your Blueprint within Apstra. Feature set as of version 0.0.7: manage all resources supports tagging idempotent Suported Resources: Resource Type Ansible module parameter \"type\" ASN Pool asn-pools IPv4 Pool ip-pools IPv6 Pool ipv6-pools VLAN Pool vlan-pools VNI Pool vni-pools Example Here is a basic example of using the module to manage your resources within in Apstra - name : Create an IP Pool Resource with two prefixes cdot65.apstra.resources : # define server connectivity options server : apstra.dmz.home port : 443 validate_certs : False api_token : \"{{ api_token }}\" # define resource allocations display_name : \"Windows Servers\" tags : [] type : \"ip-pools\" subnets : - \"100.1.1.0/24\" - \"100.1.2.0/24\" # state whether you want to create or delete this resource state : present # store the output of our task as a new variable to debug later register : windows_servers_ippool Options If you'd like to see the options available for you within the module, have a look at the data model provided below. Option Type Description api_token string our API token to authenticate with Apstra address string standby asn int standby display_name string standby ipv6_address string standby port int standby ranges list standby subnets list standby server string Apstra's DNS hostname or IP address state string determine whether to create or delete resource tags list standby type string standby validate_certs bool enable or disable SSL certificate validation Data Model We can also get insight on all available options, and their expected input types, by looking at the module's data model. @staticmethod def resources_spec (): return dict ( address = dict ( required = False , type = 'str' ), asn = dict ( required = False , type = 'int' ), api_token = dict ( required = True , fallback = ( env_fallback , [ 'APSTRA_API_TOKEN' , 'APSTRA_API_TOKEN' , 'API_TOKEN' ]), no_log = True , type = 'str' ), display_name = dict ( required = True , fallback = ( env_fallback , [ 'APSTRA_USERNAME' , 'APSTRA_USERNAME' , 'USERNAME' ]), type = 'str' ), ipv6_address = dict ( required = False , type = 'str' ), port = dict ( required = True , type = 'int' ), ranges = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( first = dict ( required = True , type = 'int' ), last = dict ( required = True , type = 'int' ), ), ), server = dict ( required = False , type = 'str' ), state = dict ( required = False , choices = [ 'absent' , 'present' ], type = 'str' ), subnets = dict ( required = False , type = 'list' , elements = 'str' ), tags = dict ( required = False , type = 'list' , elements = 'str' ), type = dict ( required = True , choices = [ 'asn-pools' , 'external-routers' , 'ip-pools' , 'ipv6-pools' , 'vlan-pools' , 'vni-pools' ], type = 'str' ), validate_certs = dict ( type = 'bool' , required = False , default = False ), )","title":"Provider"},{"location":"docs/terraform/providers/ipsec/#overview","text":"The cdot65.apstra.resources module will allow you to manage the configuration of your Blueprint within Apstra. Feature set as of version 0.0.7: manage all resources supports tagging idempotent Suported Resources: Resource Type Ansible module parameter \"type\" ASN Pool asn-pools IPv4 Pool ip-pools IPv6 Pool ipv6-pools VLAN Pool vlan-pools VNI Pool vni-pools","title":"\ud83d\udccc Overview"},{"location":"docs/terraform/providers/ipsec/#example","text":"Here is a basic example of using the module to manage your resources within in Apstra - name : Create an IP Pool Resource with two prefixes cdot65.apstra.resources : # define server connectivity options server : apstra.dmz.home port : 443 validate_certs : False api_token : \"{{ api_token }}\" # define resource allocations display_name : \"Windows Servers\" tags : [] type : \"ip-pools\" subnets : - \"100.1.1.0/24\" - \"100.1.2.0/24\" # state whether you want to create or delete this resource state : present # store the output of our task as a new variable to debug later register : windows_servers_ippool","title":"Example"},{"location":"docs/terraform/providers/ipsec/#options","text":"If you'd like to see the options available for you within the module, have a look at the data model provided below. Option Type Description api_token string our API token to authenticate with Apstra address string standby asn int standby display_name string standby ipv6_address string standby port int standby ranges list standby subnets list standby server string Apstra's DNS hostname or IP address state string determine whether to create or delete resource tags list standby type string standby validate_certs bool enable or disable SSL certificate validation","title":"Options"},{"location":"docs/terraform/providers/ipsec/#data-model","text":"We can also get insight on all available options, and their expected input types, by looking at the module's data model. @staticmethod def resources_spec (): return dict ( address = dict ( required = False , type = 'str' ), asn = dict ( required = False , type = 'int' ), api_token = dict ( required = True , fallback = ( env_fallback , [ 'APSTRA_API_TOKEN' , 'APSTRA_API_TOKEN' , 'API_TOKEN' ]), no_log = True , type = 'str' ), display_name = dict ( required = True , fallback = ( env_fallback , [ 'APSTRA_USERNAME' , 'APSTRA_USERNAME' , 'USERNAME' ]), type = 'str' ), ipv6_address = dict ( required = False , type = 'str' ), port = dict ( required = True , type = 'int' ), ranges = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( first = dict ( required = True , type = 'int' ), last = dict ( required = True , type = 'int' ), ), ), server = dict ( required = False , type = 'str' ), state = dict ( required = False , choices = [ 'absent' , 'present' ], type = 'str' ), subnets = dict ( required = False , type = 'list' , elements = 'str' ), tags = dict ( required = False , type = 'list' , elements = 'str' ), type = dict ( required = True , choices = [ 'asn-pools' , 'external-routers' , 'ip-pools' , 'ipv6-pools' , 'vlan-pools' , 'vni-pools' ], type = 'str' ), validate_certs = dict ( type = 'bool' , required = False , default = False ), )","title":"Data Model"},{"location":"docs/terraform/resources/addressbook/","text":"\ud83c\udf89 Welcome This project is for network developers looking to build, deploy, and validate an edge network design with Juniper Apstra and RedHat Ansible . For those looking to get started with either network automation or VXLAN/EVPN fabrics, this project can help you get familiar with the concepts and technologies necessary for success. \u2753 How to use this guide The navigation menu on the left hand of this site will be the best method of navigating between the documents. Automation This is where we will cover the automation covered by our Ansible Collection. Information about Roles, Plugins, and Modules will be discussed in detail. The all-important code deep dive will be taking place here, as well as a discussion around the various tools provided within the project to make our lives easier. Network This can be considered optional if you're only here for the Ansible, but it's really cool too. We will cover topics like IP addressing, VXLAN/EVPN fabric design, and control-plane details. Lab Environment We have provided a lab in Juniper vLabs to accompany this guide; an EVE-NG topology file has also been provided for those without access to Juniper vLabs. This section can be considered optional, only to be referenced if you're planning to execute this project firsthand.","title":"Resources"},{"location":"docs/terraform/resources/addressbook/#welcome","text":"This project is for network developers looking to build, deploy, and validate an edge network design with Juniper Apstra and RedHat Ansible . For those looking to get started with either network automation or VXLAN/EVPN fabrics, this project can help you get familiar with the concepts and technologies necessary for success.","title":"\ud83c\udf89 Welcome"},{"location":"docs/terraform/resources/addressbook/#how-to-use-this-guide","text":"The navigation menu on the left hand of this site will be the best method of navigating between the documents.","title":"\u2753 How to use this guide"},{"location":"docs/terraform/resources/addressbook/#automation","text":"This is where we will cover the automation covered by our Ansible Collection. Information about Roles, Plugins, and Modules will be discussed in detail. The all-important code deep dive will be taking place here, as well as a discussion around the various tools provided within the project to make our lives easier.","title":"Automation"},{"location":"docs/terraform/resources/addressbook/#network","text":"This can be considered optional if you're only here for the Ansible, but it's really cool too. We will cover topics like IP addressing, VXLAN/EVPN fabric design, and control-plane details.","title":"Network"},{"location":"docs/terraform/resources/addressbook/#lab-environment","text":"We have provided a lab in Juniper vLabs to accompany this guide; an EVE-NG topology file has also been provided for those without access to Juniper vLabs. This section can be considered optional, only to be referenced if you're planning to execute this project firsthand.","title":"Lab Environment"},{"location":"docs/terraform/resources/ike/","text":"\ud83d\udccc Overview The cdot65.apstra.design module will allow you to manage your design elements within Apstra. Feature set as of version 0.0.14: manage Logical Devices, Rack Types, Templates, Intereface Mapping idempotent Suported Resources: Design Element How to specify within Ansible module parameter \"type\" Interface Mapping interface-maps Logical Device logical-devices Rack Types rack-types Templates templates Example - name : Create a logical device cdot65.apstra.design : # define how to connect to Apstra server server : apstra.dmz.home port : 443 validate_certs : False api_token : \"{{ api_token }}\" # define design element (a new logical device) type : \"logical-devices\" display_name : \"cool-switch-vendor\" panels : - panel_layout : # rack unit height and width row_count : 1 column_count : 12 port_indexing : # top to bottom, left to right, start with number 1 order : \"T-B, L-R\" schema : \"absolute\" start_index : 1 port_groups : # 12 interfaces, all capable of a leaf role with 10GbE - count : 12 roles : - leaf speed : value : 10 unit : \"G\" # state whether you want to create or delete this resource state : present Options If you'd like to see the options available for you within the module, have a look at the data model provided below. Option Type Description access_switches list standby api_token string our API token to authenticate with Apstra description string standby device_profile_id string standby display_name int standby id string standby interfaces list standby label string standby leafs list standby logical_devices list standby logical_device_id str standby name str standby panels dict standby port int standby server str standby servers list standby state str standby design_template dict standby type str standby validate_certs bool standby Data Model We can also get insight on all available options, and their expected input types, by looking at the module's data model. @staticmethod def design_spec (): return dict ( access_switches = dict ( required = False , type = 'list' , elements = 'str' ), api_token = dict ( required = True , fallback = ( env_fallback , [ 'APSTRA_API_TOKEN' , 'API_TOKEN' ] ), no_log = True , type = 'str' ), description = dict ( required = False , type = 'str' ), device_profile_id = dict ( required = False , type = 'str' ), display_name = dict ( required = True , fallback = ( env_fallback , [ 'APSTRA_USERNAME' , 'USERNAME' ] ), type = 'str' ), id = dict ( required = False , type = 'str' ), interfaces = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( mapping = dict ( required = True , type = 'list' , elements = 'int' ), name = dict ( required = True , type = 'str' , ), position = dict ( required = True , type = 'int' , ), roles = dict ( required = True , type = 'list' , elements = 'str' ), setting = dict ( required = True , type = 'dict' , options = dict ( param = dict ( required = False , type = 'str' ), ) ), speed = dict ( required = True , type = 'dict' , options = dict ( unit = dict ( required = False , type = 'str' ), value = dict ( required = False , type = 'int' ), ) ), state = dict ( required = True , type = 'str' , ), ), ), label = dict ( required = False , type = 'str' ), leafs = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( external_router_facing = dict ( required = True , type = 'bool' , ), external_router_links = dict ( required = True , type = 'list' , elements = 'str' ), label = dict ( required = False , type = 'str' , ), leaf_leaf_l3_link_count = dict ( required = False , type = 'int' , ), leaf_leaf_l3_link_port_channel_id = dict ( required = False , type = 'int' , ), leaf_leaf_l3_link_speed = dict ( required = False , type = 'str' , ), leaf_leaf_link_count = dict ( required = False , type = 'int' , ), leaf_leaf_link_port_channel_id = dict ( required = False , type = 'int' , ), leaf_leaf_link_speed = dict ( required = False , type = 'str' , ), link_per_spine_count = dict ( required = False , type = 'int' , ), link_per_spine_speed = dict ( required = True , type = 'dict' , options = dict ( unit = dict ( required = False , type = 'str' ), value = dict ( required = False , type = 'int' ) ) ), logical_device = dict ( required = False , type = 'str' , ), redundancy_protocol = dict ( required = False , type = 'str' , ), ), ), logical_devices = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( display_name = dict ( required = True , type = 'str' , ), id = dict ( required = True , type = 'str' , ), panels = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( panel_layout = dict ( required = True , type = 'dict' , options = dict ( row_count = dict ( required = False , type = 'int' ), column_count = dict ( required = False , type = 'int' ), ) ), port_indexing = dict ( required = True , type = 'dict' , options = dict ( order = dict ( required = False , type = 'str' ), start_index = dict ( required = False , type = 'int' ), schema = dict ( required = False , type = 'str' ), ) ), port_groups = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( count = dict ( required = False , type = 'int' ), roles = dict ( required = False , type = 'list' , elements = 'str' ), speed = dict ( required = True , type = 'dict' , options = dict ( unit = dict ( required = False , type = 'str' ), value = dict ( required = False , type = 'int' ), ) ), ), ), ), ), ), ), logical_device_id = dict ( required = False , type = 'str' ), name = dict ( required = False , type = 'str' ), panels = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( panel_layout = dict ( required = True , type = 'dict' , options = dict ( row_count = dict ( required = False , type = 'int' ), column_count = dict ( required = False , type = 'int' ), ) ), port_indexing = dict ( required = True , type = 'dict' , options = dict ( order = dict ( required = False , type = 'str' ), schema = dict ( required = False , type = 'str' ), start_index = dict ( required = False , type = 'int' ), ), ), port_groups = dict ( required = True , type = 'list' , elements = 'dict' , options = dict ( count = dict ( required = False , type = 'int' ), roles = dict ( required = False , type = 'list' , elements = 'str' ), speed = dict ( required = False , type = 'dict' , options = dict ( value = dict ( required = False , type = 'int' ), unit = dict ( required = False , type = 'str' ), ), ), ), ), ), ), port = dict ( required = False , type = 'int' ), server = dict ( required = False , type = 'str' ), servers = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( connectivity_type = dict ( required = True , type = 'str' , ), count = dict ( required = True , type = 'int' , ), label = dict ( required = True , type = 'str' , ), logical_device = dict ( required = True , type = 'str' , ), ip_version = dict ( required = True , type = 'str' , ), port_channel_id_min = dict ( required = True , type = 'int' , ), port_channel_id_max = dict ( required = True , type = 'int' , ), links = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( attachment_type = dict ( required = False , type = 'str' ), label = dict ( required = False , type = 'str' ), lag_mode = dict ( required = False , type = 'str' ), leaf_peer = dict ( required = False , type = 'str' ), link_per_switch_count = dict ( required = False , type = 'int' ), link_speed = dict ( required = True , type = 'dict' , options = dict ( unit = dict ( required = False , type = 'str' ), value = dict ( required = False , type = 'int' ), ) ), target_switch_label = dict ( required = False , type = 'str' ), ), ), ), ), state = dict ( required = True , choices = [ 'absent' , 'present' ], type = 'str' ), design_template = dict ( required = False , type = 'dict' , options = dict ( asn_allocation_policy = dict ( required = False , type = 'dict' , options = dict ( spine_asn_scheme = dict ( required = False , type = 'str' ) ) ), dhcp_service_intent = dict ( required = False , type = 'dict' , options = dict ( active = dict ( required = False , type = 'bool' ) ) ), display_name = dict ( required = True , type = 'str' ), external_routing_policy = dict ( required = False , type = 'dict' , options = dict ( export_policy = dict ( required = False , type = 'dict' , options = dict ( all_routes = dict ( required = False , type = 'bool' ), l2edge_subnets = dict ( required = False , type = 'bool' ), l3edge_server_links = dict ( required = False , type = 'bool' ), loopbacks = dict ( required = False , type = 'bool' ), spine_leaf_links = dict ( required = False , type = 'bool' ), ) ), import_policy = dict ( required = False , type = 'str' ) ) ), fabric_addressing_policy = dict ( required = False , type = 'dict' , options = dict ( spine_leaf_links = dict ( required = False , type = 'str' ) ) ), rack_type_counts = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( count = dict ( required = False , type = 'int' ), rack_type_id = dict ( required = False , type = 'str' ), ) ), rack_types = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( access_switches = dict ( required = False , type = 'list' , elements = 'str' ), description = dict ( required = False , type = 'str' ), display_name = dict ( required = False , type = 'str' ), id = dict ( required = False , type = 'str' ), leafs = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( external_router_facing = dict ( required = False , type = 'bool' ), external_router_links = dict ( required = False , type = 'list' , elements = 'str' ), label = dict ( required = False , type = 'str' ), leaf_leaf_l3_link_count = dict ( required = False , type = 'int' ), leaf_leaf_l3_link_port_channel_id = dict ( required = False , type = 'int' ), leaf_leaf_l3_link_speed = dict ( required = False , type = 'str' ), leaf_leaf_link_count = dict ( required = False , type = 'int' ), leaf_leaf_link_port_channel_id = dict ( required = False , type = 'int' ), leaf_leaf_link_speed = dict ( required = False , type = 'str' ), link_per_spine_count = dict ( required = False , type = 'int' ), link_per_spine_speed = dict ( required = False , type = 'dict' , options = dict ( unit = dict ( type = 'str' , required = False ), value = dict ( type = 'int' , required = False ) ) ), logical_device = dict ( required = True , type = 'str' ), redundancy_protocol = dict ( required = False , type = 'str' ), ) ), logical_devices = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( display_name = dict ( required = True , type = 'str' ), id = dict ( required = True , type = 'str' ), panels = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( panel_layout = dict ( required = False , type = 'dict' , options = dict ( column_count = dict ( required = False , type = 'int' ), row_count = dict ( required = False , type = 'int' ) ) ), port_groups = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( count = dict ( required = False , type = 'int' ), roles = dict ( required = False , type = 'list' , elements = 'str' ), speed = dict ( required = False , type = 'dict' , options = dict ( unit = dict ( required = False , type = 'str' ), value = dict ( required = False , type = 'int' ), ) ), ) ), port_indexing = dict ( required = True , type = 'dict' , options = dict ( order = dict ( required = True , type = 'str' ), schema = dict ( required = True , type = 'str' ), start_index = dict ( required = True , type = 'int' ), ) ) ) ) ) ), servers = dict ( required = True , type = 'list' , elements = 'dict' , options = dict ( connectivity_type = dict ( type = 'str' , required = True ), count = dict ( type = 'int' , required = True ), ip_version = dict ( type = 'str' , required = True ), label = dict ( type = 'str' , required = True ), links = dict ( required = True , type = 'list' , elements = 'dict' , options = dict ( attachment_type = dict ( type = 'str' , required = True ), label = dict ( type = 'str' , required = True ), lag_mode = dict ( type = 'str' , required = False ), link_per_switch_count = dict ( type = 'int' , required = False ), link_speed = dict ( required = True , type = 'dict' , options = dict ( unit = dict ( type = 'str' , required = False ), value = dict ( type = 'int' , required = False ) ) ), target_switch_label = dict ( type = 'str' , required = True ) ) ), logical_device = dict ( type = 'str' , required = True ), port_channel_id_max = dict ( type = 'int' , required = False ), port_channel_id_min = dict ( type = 'int' , required = False ) ) ) ) ), spine = dict ( required = True , type = 'dict' , options = dict ( count = dict ( required = True , type = 'int' ), external_link_count = dict ( required = True , type = 'int' ), external_link_speed = dict ( required = True , type = 'str' ), link_per_superspine_count = dict ( required = True , type = 'int' ), link_per_superspine_speed = dict ( required = True , type = 'str' ), logical_device = dict ( required = True , type = 'dict' , options = dict ( display_name = dict ( required = True , type = 'str' ), id = dict ( required = True , type = 'str' ), panels = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( panel_layout = dict ( required = False , type = 'dict' , options = dict ( column_count = dict ( required = False , type = 'int' ), row_count = dict ( required = False , type = 'int' ) ) ), port_groups = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( count = dict ( required = False , type = 'int' ), roles = dict ( required = False , type = 'list' , elements = 'str' ), speed = dict ( required = False , type = 'dict' , options = dict ( unit = dict ( required = False , type = 'str' ), value = dict ( required = False , type = 'int' ) ) ) ) ), port_indexing = dict ( required = False , type = 'dict' , options = dict ( order = dict ( type = 'str' , required = False ), schema = dict ( type = 'str' , required = False ), start_index = dict ( type = 'int' , required = False ) ) ) ) ) ) ) ) ), type = dict ( required = True , type = 'str' ), virtual_network_policy = dict ( required = True , type = 'dict' , options = dict ( overlay_control_protocol = dict ( required = True , type = 'str' ) ) ) ) ), type = dict ( required = True , choices = [ 'logical-devices' , 'interface-maps' , 'rack-types' , 'templates' ], type = 'str' ), validate_certs = dict ( type = 'bool' , required = False , default = False ), )","title":"Resources"},{"location":"docs/terraform/resources/ike/#overview","text":"The cdot65.apstra.design module will allow you to manage your design elements within Apstra. Feature set as of version 0.0.14: manage Logical Devices, Rack Types, Templates, Intereface Mapping idempotent Suported Resources: Design Element How to specify within Ansible module parameter \"type\" Interface Mapping interface-maps Logical Device logical-devices Rack Types rack-types Templates templates","title":"\ud83d\udccc Overview"},{"location":"docs/terraform/resources/ike/#example","text":"- name : Create a logical device cdot65.apstra.design : # define how to connect to Apstra server server : apstra.dmz.home port : 443 validate_certs : False api_token : \"{{ api_token }}\" # define design element (a new logical device) type : \"logical-devices\" display_name : \"cool-switch-vendor\" panels : - panel_layout : # rack unit height and width row_count : 1 column_count : 12 port_indexing : # top to bottom, left to right, start with number 1 order : \"T-B, L-R\" schema : \"absolute\" start_index : 1 port_groups : # 12 interfaces, all capable of a leaf role with 10GbE - count : 12 roles : - leaf speed : value : 10 unit : \"G\" # state whether you want to create or delete this resource state : present","title":"Example"},{"location":"docs/terraform/resources/ike/#options","text":"If you'd like to see the options available for you within the module, have a look at the data model provided below. Option Type Description access_switches list standby api_token string our API token to authenticate with Apstra description string standby device_profile_id string standby display_name int standby id string standby interfaces list standby label string standby leafs list standby logical_devices list standby logical_device_id str standby name str standby panels dict standby port int standby server str standby servers list standby state str standby design_template dict standby type str standby validate_certs bool standby","title":"Options"},{"location":"docs/terraform/resources/ike/#data-model","text":"We can also get insight on all available options, and their expected input types, by looking at the module's data model. @staticmethod def design_spec (): return dict ( access_switches = dict ( required = False , type = 'list' , elements = 'str' ), api_token = dict ( required = True , fallback = ( env_fallback , [ 'APSTRA_API_TOKEN' , 'API_TOKEN' ] ), no_log = True , type = 'str' ), description = dict ( required = False , type = 'str' ), device_profile_id = dict ( required = False , type = 'str' ), display_name = dict ( required = True , fallback = ( env_fallback , [ 'APSTRA_USERNAME' , 'USERNAME' ] ), type = 'str' ), id = dict ( required = False , type = 'str' ), interfaces = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( mapping = dict ( required = True , type = 'list' , elements = 'int' ), name = dict ( required = True , type = 'str' , ), position = dict ( required = True , type = 'int' , ), roles = dict ( required = True , type = 'list' , elements = 'str' ), setting = dict ( required = True , type = 'dict' , options = dict ( param = dict ( required = False , type = 'str' ), ) ), speed = dict ( required = True , type = 'dict' , options = dict ( unit = dict ( required = False , type = 'str' ), value = dict ( required = False , type = 'int' ), ) ), state = dict ( required = True , type = 'str' , ), ), ), label = dict ( required = False , type = 'str' ), leafs = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( external_router_facing = dict ( required = True , type = 'bool' , ), external_router_links = dict ( required = True , type = 'list' , elements = 'str' ), label = dict ( required = False , type = 'str' , ), leaf_leaf_l3_link_count = dict ( required = False , type = 'int' , ), leaf_leaf_l3_link_port_channel_id = dict ( required = False , type = 'int' , ), leaf_leaf_l3_link_speed = dict ( required = False , type = 'str' , ), leaf_leaf_link_count = dict ( required = False , type = 'int' , ), leaf_leaf_link_port_channel_id = dict ( required = False , type = 'int' , ), leaf_leaf_link_speed = dict ( required = False , type = 'str' , ), link_per_spine_count = dict ( required = False , type = 'int' , ), link_per_spine_speed = dict ( required = True , type = 'dict' , options = dict ( unit = dict ( required = False , type = 'str' ), value = dict ( required = False , type = 'int' ) ) ), logical_device = dict ( required = False , type = 'str' , ), redundancy_protocol = dict ( required = False , type = 'str' , ), ), ), logical_devices = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( display_name = dict ( required = True , type = 'str' , ), id = dict ( required = True , type = 'str' , ), panels = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( panel_layout = dict ( required = True , type = 'dict' , options = dict ( row_count = dict ( required = False , type = 'int' ), column_count = dict ( required = False , type = 'int' ), ) ), port_indexing = dict ( required = True , type = 'dict' , options = dict ( order = dict ( required = False , type = 'str' ), start_index = dict ( required = False , type = 'int' ), schema = dict ( required = False , type = 'str' ), ) ), port_groups = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( count = dict ( required = False , type = 'int' ), roles = dict ( required = False , type = 'list' , elements = 'str' ), speed = dict ( required = True , type = 'dict' , options = dict ( unit = dict ( required = False , type = 'str' ), value = dict ( required = False , type = 'int' ), ) ), ), ), ), ), ), ), logical_device_id = dict ( required = False , type = 'str' ), name = dict ( required = False , type = 'str' ), panels = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( panel_layout = dict ( required = True , type = 'dict' , options = dict ( row_count = dict ( required = False , type = 'int' ), column_count = dict ( required = False , type = 'int' ), ) ), port_indexing = dict ( required = True , type = 'dict' , options = dict ( order = dict ( required = False , type = 'str' ), schema = dict ( required = False , type = 'str' ), start_index = dict ( required = False , type = 'int' ), ), ), port_groups = dict ( required = True , type = 'list' , elements = 'dict' , options = dict ( count = dict ( required = False , type = 'int' ), roles = dict ( required = False , type = 'list' , elements = 'str' ), speed = dict ( required = False , type = 'dict' , options = dict ( value = dict ( required = False , type = 'int' ), unit = dict ( required = False , type = 'str' ), ), ), ), ), ), ), port = dict ( required = False , type = 'int' ), server = dict ( required = False , type = 'str' ), servers = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( connectivity_type = dict ( required = True , type = 'str' , ), count = dict ( required = True , type = 'int' , ), label = dict ( required = True , type = 'str' , ), logical_device = dict ( required = True , type = 'str' , ), ip_version = dict ( required = True , type = 'str' , ), port_channel_id_min = dict ( required = True , type = 'int' , ), port_channel_id_max = dict ( required = True , type = 'int' , ), links = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( attachment_type = dict ( required = False , type = 'str' ), label = dict ( required = False , type = 'str' ), lag_mode = dict ( required = False , type = 'str' ), leaf_peer = dict ( required = False , type = 'str' ), link_per_switch_count = dict ( required = False , type = 'int' ), link_speed = dict ( required = True , type = 'dict' , options = dict ( unit = dict ( required = False , type = 'str' ), value = dict ( required = False , type = 'int' ), ) ), target_switch_label = dict ( required = False , type = 'str' ), ), ), ), ), state = dict ( required = True , choices = [ 'absent' , 'present' ], type = 'str' ), design_template = dict ( required = False , type = 'dict' , options = dict ( asn_allocation_policy = dict ( required = False , type = 'dict' , options = dict ( spine_asn_scheme = dict ( required = False , type = 'str' ) ) ), dhcp_service_intent = dict ( required = False , type = 'dict' , options = dict ( active = dict ( required = False , type = 'bool' ) ) ), display_name = dict ( required = True , type = 'str' ), external_routing_policy = dict ( required = False , type = 'dict' , options = dict ( export_policy = dict ( required = False , type = 'dict' , options = dict ( all_routes = dict ( required = False , type = 'bool' ), l2edge_subnets = dict ( required = False , type = 'bool' ), l3edge_server_links = dict ( required = False , type = 'bool' ), loopbacks = dict ( required = False , type = 'bool' ), spine_leaf_links = dict ( required = False , type = 'bool' ), ) ), import_policy = dict ( required = False , type = 'str' ) ) ), fabric_addressing_policy = dict ( required = False , type = 'dict' , options = dict ( spine_leaf_links = dict ( required = False , type = 'str' ) ) ), rack_type_counts = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( count = dict ( required = False , type = 'int' ), rack_type_id = dict ( required = False , type = 'str' ), ) ), rack_types = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( access_switches = dict ( required = False , type = 'list' , elements = 'str' ), description = dict ( required = False , type = 'str' ), display_name = dict ( required = False , type = 'str' ), id = dict ( required = False , type = 'str' ), leafs = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( external_router_facing = dict ( required = False , type = 'bool' ), external_router_links = dict ( required = False , type = 'list' , elements = 'str' ), label = dict ( required = False , type = 'str' ), leaf_leaf_l3_link_count = dict ( required = False , type = 'int' ), leaf_leaf_l3_link_port_channel_id = dict ( required = False , type = 'int' ), leaf_leaf_l3_link_speed = dict ( required = False , type = 'str' ), leaf_leaf_link_count = dict ( required = False , type = 'int' ), leaf_leaf_link_port_channel_id = dict ( required = False , type = 'int' ), leaf_leaf_link_speed = dict ( required = False , type = 'str' ), link_per_spine_count = dict ( required = False , type = 'int' ), link_per_spine_speed = dict ( required = False , type = 'dict' , options = dict ( unit = dict ( type = 'str' , required = False ), value = dict ( type = 'int' , required = False ) ) ), logical_device = dict ( required = True , type = 'str' ), redundancy_protocol = dict ( required = False , type = 'str' ), ) ), logical_devices = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( display_name = dict ( required = True , type = 'str' ), id = dict ( required = True , type = 'str' ), panels = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( panel_layout = dict ( required = False , type = 'dict' , options = dict ( column_count = dict ( required = False , type = 'int' ), row_count = dict ( required = False , type = 'int' ) ) ), port_groups = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( count = dict ( required = False , type = 'int' ), roles = dict ( required = False , type = 'list' , elements = 'str' ), speed = dict ( required = False , type = 'dict' , options = dict ( unit = dict ( required = False , type = 'str' ), value = dict ( required = False , type = 'int' ), ) ), ) ), port_indexing = dict ( required = True , type = 'dict' , options = dict ( order = dict ( required = True , type = 'str' ), schema = dict ( required = True , type = 'str' ), start_index = dict ( required = True , type = 'int' ), ) ) ) ) ) ), servers = dict ( required = True , type = 'list' , elements = 'dict' , options = dict ( connectivity_type = dict ( type = 'str' , required = True ), count = dict ( type = 'int' , required = True ), ip_version = dict ( type = 'str' , required = True ), label = dict ( type = 'str' , required = True ), links = dict ( required = True , type = 'list' , elements = 'dict' , options = dict ( attachment_type = dict ( type = 'str' , required = True ), label = dict ( type = 'str' , required = True ), lag_mode = dict ( type = 'str' , required = False ), link_per_switch_count = dict ( type = 'int' , required = False ), link_speed = dict ( required = True , type = 'dict' , options = dict ( unit = dict ( type = 'str' , required = False ), value = dict ( type = 'int' , required = False ) ) ), target_switch_label = dict ( type = 'str' , required = True ) ) ), logical_device = dict ( type = 'str' , required = True ), port_channel_id_max = dict ( type = 'int' , required = False ), port_channel_id_min = dict ( type = 'int' , required = False ) ) ) ) ), spine = dict ( required = True , type = 'dict' , options = dict ( count = dict ( required = True , type = 'int' ), external_link_count = dict ( required = True , type = 'int' ), external_link_speed = dict ( required = True , type = 'str' ), link_per_superspine_count = dict ( required = True , type = 'int' ), link_per_superspine_speed = dict ( required = True , type = 'str' ), logical_device = dict ( required = True , type = 'dict' , options = dict ( display_name = dict ( required = True , type = 'str' ), id = dict ( required = True , type = 'str' ), panels = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( panel_layout = dict ( required = False , type = 'dict' , options = dict ( column_count = dict ( required = False , type = 'int' ), row_count = dict ( required = False , type = 'int' ) ) ), port_groups = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( count = dict ( required = False , type = 'int' ), roles = dict ( required = False , type = 'list' , elements = 'str' ), speed = dict ( required = False , type = 'dict' , options = dict ( unit = dict ( required = False , type = 'str' ), value = dict ( required = False , type = 'int' ) ) ) ) ), port_indexing = dict ( required = False , type = 'dict' , options = dict ( order = dict ( type = 'str' , required = False ), schema = dict ( type = 'str' , required = False ), start_index = dict ( type = 'int' , required = False ) ) ) ) ) ) ) ) ), type = dict ( required = True , type = 'str' ), virtual_network_policy = dict ( required = True , type = 'dict' , options = dict ( overlay_control_protocol = dict ( required = True , type = 'str' ) ) ) ) ), type = dict ( required = True , choices = [ 'logical-devices' , 'interface-maps' , 'rack-types' , 'templates' ], type = 'str' ), validate_certs = dict ( type = 'bool' , required = False , default = False ), )","title":"Data Model"},{"location":"docs/terraform/resources/ipsec/","text":"\ud83d\udccc Overview The cdot65.apstra.resources module will allow you to manage the configuration of your Blueprint within Apstra. Feature set as of version 0.0.7: manage all resources supports tagging idempotent Suported Resources: Resource Type Ansible module parameter \"type\" ASN Pool asn-pools IPv4 Pool ip-pools IPv6 Pool ipv6-pools VLAN Pool vlan-pools VNI Pool vni-pools Example Here is a basic example of using the module to manage your resources within in Apstra - name : Create an IP Pool Resource with two prefixes cdot65.apstra.resources : # define server connectivity options server : apstra.dmz.home port : 443 validate_certs : False api_token : \"{{ api_token }}\" # define resource allocations display_name : \"Windows Servers\" tags : [] type : \"ip-pools\" subnets : - \"100.1.1.0/24\" - \"100.1.2.0/24\" # state whether you want to create or delete this resource state : present # store the output of our task as a new variable to debug later register : windows_servers_ippool Options If you'd like to see the options available for you within the module, have a look at the data model provided below. Option Type Description api_token string our API token to authenticate with Apstra address string standby asn int standby display_name string standby ipv6_address string standby port int standby ranges list standby subnets list standby server string Apstra's DNS hostname or IP address state string determine whether to create or delete resource tags list standby type string standby validate_certs bool enable or disable SSL certificate validation Data Model We can also get insight on all available options, and their expected input types, by looking at the module's data model. @staticmethod def resources_spec (): return dict ( address = dict ( required = False , type = 'str' ), asn = dict ( required = False , type = 'int' ), api_token = dict ( required = True , fallback = ( env_fallback , [ 'APSTRA_API_TOKEN' , 'APSTRA_API_TOKEN' , 'API_TOKEN' ]), no_log = True , type = 'str' ), display_name = dict ( required = True , fallback = ( env_fallback , [ 'APSTRA_USERNAME' , 'APSTRA_USERNAME' , 'USERNAME' ]), type = 'str' ), ipv6_address = dict ( required = False , type = 'str' ), port = dict ( required = True , type = 'int' ), ranges = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( first = dict ( required = True , type = 'int' ), last = dict ( required = True , type = 'int' ), ), ), server = dict ( required = False , type = 'str' ), state = dict ( required = False , choices = [ 'absent' , 'present' ], type = 'str' ), subnets = dict ( required = False , type = 'list' , elements = 'str' ), tags = dict ( required = False , type = 'list' , elements = 'str' ), type = dict ( required = True , choices = [ 'asn-pools' , 'external-routers' , 'ip-pools' , 'ipv6-pools' , 'vlan-pools' , 'vni-pools' ], type = 'str' ), validate_certs = dict ( type = 'bool' , required = False , default = False ), )","title":"Resources"},{"location":"docs/terraform/resources/ipsec/#overview","text":"The cdot65.apstra.resources module will allow you to manage the configuration of your Blueprint within Apstra. Feature set as of version 0.0.7: manage all resources supports tagging idempotent Suported Resources: Resource Type Ansible module parameter \"type\" ASN Pool asn-pools IPv4 Pool ip-pools IPv6 Pool ipv6-pools VLAN Pool vlan-pools VNI Pool vni-pools","title":"\ud83d\udccc Overview"},{"location":"docs/terraform/resources/ipsec/#example","text":"Here is a basic example of using the module to manage your resources within in Apstra - name : Create an IP Pool Resource with two prefixes cdot65.apstra.resources : # define server connectivity options server : apstra.dmz.home port : 443 validate_certs : False api_token : \"{{ api_token }}\" # define resource allocations display_name : \"Windows Servers\" tags : [] type : \"ip-pools\" subnets : - \"100.1.1.0/24\" - \"100.1.2.0/24\" # state whether you want to create or delete this resource state : present # store the output of our task as a new variable to debug later register : windows_servers_ippool","title":"Example"},{"location":"docs/terraform/resources/ipsec/#options","text":"If you'd like to see the options available for you within the module, have a look at the data model provided below. Option Type Description api_token string our API token to authenticate with Apstra address string standby asn int standby display_name string standby ipv6_address string standby port int standby ranges list standby subnets list standby server string Apstra's DNS hostname or IP address state string determine whether to create or delete resource tags list standby type string standby validate_certs bool enable or disable SSL certificate validation","title":"Options"},{"location":"docs/terraform/resources/ipsec/#data-model","text":"We can also get insight on all available options, and their expected input types, by looking at the module's data model. @staticmethod def resources_spec (): return dict ( address = dict ( required = False , type = 'str' ), asn = dict ( required = False , type = 'int' ), api_token = dict ( required = True , fallback = ( env_fallback , [ 'APSTRA_API_TOKEN' , 'APSTRA_API_TOKEN' , 'API_TOKEN' ]), no_log = True , type = 'str' ), display_name = dict ( required = True , fallback = ( env_fallback , [ 'APSTRA_USERNAME' , 'APSTRA_USERNAME' , 'USERNAME' ]), type = 'str' ), ipv6_address = dict ( required = False , type = 'str' ), port = dict ( required = True , type = 'int' ), ranges = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( first = dict ( required = True , type = 'int' ), last = dict ( required = True , type = 'int' ), ), ), server = dict ( required = False , type = 'str' ), state = dict ( required = False , choices = [ 'absent' , 'present' ], type = 'str' ), subnets = dict ( required = False , type = 'list' , elements = 'str' ), tags = dict ( required = False , type = 'list' , elements = 'str' ), type = dict ( required = True , choices = [ 'asn-pools' , 'external-routers' , 'ip-pools' , 'ipv6-pools' , 'vlan-pools' , 'vni-pools' ], type = 'str' ), validate_certs = dict ( type = 'bool' , required = False , default = False ), )","title":"Data Model"},{"location":"docs/terraform/workspaces/addressbook/","text":"\ud83c\udf89 Welcome This project is for network developers looking to build, deploy, and validate an edge network design with Juniper Apstra and RedHat Ansible . For those looking to get started with either network automation or VXLAN/EVPN fabrics, this project can help you get familiar with the concepts and technologies necessary for success. \u2753 How to use this guide The navigation menu on the left hand of this site will be the best method of navigating between the documents. Automation This is where we will cover the automation covered by our Ansible Collection. Information about Roles, Plugins, and Modules will be discussed in detail. The all-important code deep dive will be taking place here, as well as a discussion around the various tools provided within the project to make our lives easier. Network This can be considered optional if you're only here for the Ansible, but it's really cool too. We will cover topics like IP addressing, VXLAN/EVPN fabric design, and control-plane details. Lab Environment We have provided a lab in Juniper vLabs to accompany this guide; an EVE-NG topology file has also been provided for those without access to Juniper vLabs. This section can be considered optional, only to be referenced if you're planning to execute this project firsthand.","title":"Workspace"},{"location":"docs/terraform/workspaces/addressbook/#welcome","text":"This project is for network developers looking to build, deploy, and validate an edge network design with Juniper Apstra and RedHat Ansible . For those looking to get started with either network automation or VXLAN/EVPN fabrics, this project can help you get familiar with the concepts and technologies necessary for success.","title":"\ud83c\udf89 Welcome"},{"location":"docs/terraform/workspaces/addressbook/#how-to-use-this-guide","text":"The navigation menu on the left hand of this site will be the best method of navigating between the documents.","title":"\u2753 How to use this guide"},{"location":"docs/terraform/workspaces/addressbook/#automation","text":"This is where we will cover the automation covered by our Ansible Collection. Information about Roles, Plugins, and Modules will be discussed in detail. The all-important code deep dive will be taking place here, as well as a discussion around the various tools provided within the project to make our lives easier.","title":"Automation"},{"location":"docs/terraform/workspaces/addressbook/#network","text":"This can be considered optional if you're only here for the Ansible, but it's really cool too. We will cover topics like IP addressing, VXLAN/EVPN fabric design, and control-plane details.","title":"Network"},{"location":"docs/terraform/workspaces/addressbook/#lab-environment","text":"We have provided a lab in Juniper vLabs to accompany this guide; an EVE-NG topology file has also been provided for those without access to Juniper vLabs. This section can be considered optional, only to be referenced if you're planning to execute this project firsthand.","title":"Lab Environment"},{"location":"docs/terraform/workspaces/ike/","text":"\ud83d\udccc Overview The cdot65.apstra.design module will allow you to manage your design elements within Apstra. Feature set as of version 0.0.14: manage Logical Devices, Rack Types, Templates, Intereface Mapping idempotent Suported Resources: Design Element How to specify within Ansible module parameter \"type\" Interface Mapping interface-maps Logical Device logical-devices Rack Types rack-types Templates templates Example - name : Create a logical device cdot65.apstra.design : # define how to connect to Apstra server server : apstra.dmz.home port : 443 validate_certs : False api_token : \"{{ api_token }}\" # define design element (a new logical device) type : \"logical-devices\" display_name : \"cool-switch-vendor\" panels : - panel_layout : # rack unit height and width row_count : 1 column_count : 12 port_indexing : # top to bottom, left to right, start with number 1 order : \"T-B, L-R\" schema : \"absolute\" start_index : 1 port_groups : # 12 interfaces, all capable of a leaf role with 10GbE - count : 12 roles : - leaf speed : value : 10 unit : \"G\" # state whether you want to create or delete this resource state : present Options If you'd like to see the options available for you within the module, have a look at the data model provided below. Option Type Description access_switches list standby api_token string our API token to authenticate with Apstra description string standby device_profile_id string standby display_name int standby id string standby interfaces list standby label string standby leafs list standby logical_devices list standby logical_device_id str standby name str standby panels dict standby port int standby server str standby servers list standby state str standby design_template dict standby type str standby validate_certs bool standby Data Model We can also get insight on all available options, and their expected input types, by looking at the module's data model. @staticmethod def design_spec (): return dict ( access_switches = dict ( required = False , type = 'list' , elements = 'str' ), api_token = dict ( required = True , fallback = ( env_fallback , [ 'APSTRA_API_TOKEN' , 'API_TOKEN' ] ), no_log = True , type = 'str' ), description = dict ( required = False , type = 'str' ), device_profile_id = dict ( required = False , type = 'str' ), display_name = dict ( required = True , fallback = ( env_fallback , [ 'APSTRA_USERNAME' , 'USERNAME' ] ), type = 'str' ), id = dict ( required = False , type = 'str' ), interfaces = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( mapping = dict ( required = True , type = 'list' , elements = 'int' ), name = dict ( required = True , type = 'str' , ), position = dict ( required = True , type = 'int' , ), roles = dict ( required = True , type = 'list' , elements = 'str' ), setting = dict ( required = True , type = 'dict' , options = dict ( param = dict ( required = False , type = 'str' ), ) ), speed = dict ( required = True , type = 'dict' , options = dict ( unit = dict ( required = False , type = 'str' ), value = dict ( required = False , type = 'int' ), ) ), state = dict ( required = True , type = 'str' , ), ), ), label = dict ( required = False , type = 'str' ), leafs = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( external_router_facing = dict ( required = True , type = 'bool' , ), external_router_links = dict ( required = True , type = 'list' , elements = 'str' ), label = dict ( required = False , type = 'str' , ), leaf_leaf_l3_link_count = dict ( required = False , type = 'int' , ), leaf_leaf_l3_link_port_channel_id = dict ( required = False , type = 'int' , ), leaf_leaf_l3_link_speed = dict ( required = False , type = 'str' , ), leaf_leaf_link_count = dict ( required = False , type = 'int' , ), leaf_leaf_link_port_channel_id = dict ( required = False , type = 'int' , ), leaf_leaf_link_speed = dict ( required = False , type = 'str' , ), link_per_spine_count = dict ( required = False , type = 'int' , ), link_per_spine_speed = dict ( required = True , type = 'dict' , options = dict ( unit = dict ( required = False , type = 'str' ), value = dict ( required = False , type = 'int' ) ) ), logical_device = dict ( required = False , type = 'str' , ), redundancy_protocol = dict ( required = False , type = 'str' , ), ), ), logical_devices = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( display_name = dict ( required = True , type = 'str' , ), id = dict ( required = True , type = 'str' , ), panels = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( panel_layout = dict ( required = True , type = 'dict' , options = dict ( row_count = dict ( required = False , type = 'int' ), column_count = dict ( required = False , type = 'int' ), ) ), port_indexing = dict ( required = True , type = 'dict' , options = dict ( order = dict ( required = False , type = 'str' ), start_index = dict ( required = False , type = 'int' ), schema = dict ( required = False , type = 'str' ), ) ), port_groups = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( count = dict ( required = False , type = 'int' ), roles = dict ( required = False , type = 'list' , elements = 'str' ), speed = dict ( required = True , type = 'dict' , options = dict ( unit = dict ( required = False , type = 'str' ), value = dict ( required = False , type = 'int' ), ) ), ), ), ), ), ), ), logical_device_id = dict ( required = False , type = 'str' ), name = dict ( required = False , type = 'str' ), panels = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( panel_layout = dict ( required = True , type = 'dict' , options = dict ( row_count = dict ( required = False , type = 'int' ), column_count = dict ( required = False , type = 'int' ), ) ), port_indexing = dict ( required = True , type = 'dict' , options = dict ( order = dict ( required = False , type = 'str' ), schema = dict ( required = False , type = 'str' ), start_index = dict ( required = False , type = 'int' ), ), ), port_groups = dict ( required = True , type = 'list' , elements = 'dict' , options = dict ( count = dict ( required = False , type = 'int' ), roles = dict ( required = False , type = 'list' , elements = 'str' ), speed = dict ( required = False , type = 'dict' , options = dict ( value = dict ( required = False , type = 'int' ), unit = dict ( required = False , type = 'str' ), ), ), ), ), ), ), port = dict ( required = False , type = 'int' ), server = dict ( required = False , type = 'str' ), servers = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( connectivity_type = dict ( required = True , type = 'str' , ), count = dict ( required = True , type = 'int' , ), label = dict ( required = True , type = 'str' , ), logical_device = dict ( required = True , type = 'str' , ), ip_version = dict ( required = True , type = 'str' , ), port_channel_id_min = dict ( required = True , type = 'int' , ), port_channel_id_max = dict ( required = True , type = 'int' , ), links = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( attachment_type = dict ( required = False , type = 'str' ), label = dict ( required = False , type = 'str' ), lag_mode = dict ( required = False , type = 'str' ), leaf_peer = dict ( required = False , type = 'str' ), link_per_switch_count = dict ( required = False , type = 'int' ), link_speed = dict ( required = True , type = 'dict' , options = dict ( unit = dict ( required = False , type = 'str' ), value = dict ( required = False , type = 'int' ), ) ), target_switch_label = dict ( required = False , type = 'str' ), ), ), ), ), state = dict ( required = True , choices = [ 'absent' , 'present' ], type = 'str' ), design_template = dict ( required = False , type = 'dict' , options = dict ( asn_allocation_policy = dict ( required = False , type = 'dict' , options = dict ( spine_asn_scheme = dict ( required = False , type = 'str' ) ) ), dhcp_service_intent = dict ( required = False , type = 'dict' , options = dict ( active = dict ( required = False , type = 'bool' ) ) ), display_name = dict ( required = True , type = 'str' ), external_routing_policy = dict ( required = False , type = 'dict' , options = dict ( export_policy = dict ( required = False , type = 'dict' , options = dict ( all_routes = dict ( required = False , type = 'bool' ), l2edge_subnets = dict ( required = False , type = 'bool' ), l3edge_server_links = dict ( required = False , type = 'bool' ), loopbacks = dict ( required = False , type = 'bool' ), spine_leaf_links = dict ( required = False , type = 'bool' ), ) ), import_policy = dict ( required = False , type = 'str' ) ) ), fabric_addressing_policy = dict ( required = False , type = 'dict' , options = dict ( spine_leaf_links = dict ( required = False , type = 'str' ) ) ), rack_type_counts = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( count = dict ( required = False , type = 'int' ), rack_type_id = dict ( required = False , type = 'str' ), ) ), rack_types = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( access_switches = dict ( required = False , type = 'list' , elements = 'str' ), description = dict ( required = False , type = 'str' ), display_name = dict ( required = False , type = 'str' ), id = dict ( required = False , type = 'str' ), leafs = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( external_router_facing = dict ( required = False , type = 'bool' ), external_router_links = dict ( required = False , type = 'list' , elements = 'str' ), label = dict ( required = False , type = 'str' ), leaf_leaf_l3_link_count = dict ( required = False , type = 'int' ), leaf_leaf_l3_link_port_channel_id = dict ( required = False , type = 'int' ), leaf_leaf_l3_link_speed = dict ( required = False , type = 'str' ), leaf_leaf_link_count = dict ( required = False , type = 'int' ), leaf_leaf_link_port_channel_id = dict ( required = False , type = 'int' ), leaf_leaf_link_speed = dict ( required = False , type = 'str' ), link_per_spine_count = dict ( required = False , type = 'int' ), link_per_spine_speed = dict ( required = False , type = 'dict' , options = dict ( unit = dict ( type = 'str' , required = False ), value = dict ( type = 'int' , required = False ) ) ), logical_device = dict ( required = True , type = 'str' ), redundancy_protocol = dict ( required = False , type = 'str' ), ) ), logical_devices = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( display_name = dict ( required = True , type = 'str' ), id = dict ( required = True , type = 'str' ), panels = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( panel_layout = dict ( required = False , type = 'dict' , options = dict ( column_count = dict ( required = False , type = 'int' ), row_count = dict ( required = False , type = 'int' ) ) ), port_groups = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( count = dict ( required = False , type = 'int' ), roles = dict ( required = False , type = 'list' , elements = 'str' ), speed = dict ( required = False , type = 'dict' , options = dict ( unit = dict ( required = False , type = 'str' ), value = dict ( required = False , type = 'int' ), ) ), ) ), port_indexing = dict ( required = True , type = 'dict' , options = dict ( order = dict ( required = True , type = 'str' ), schema = dict ( required = True , type = 'str' ), start_index = dict ( required = True , type = 'int' ), ) ) ) ) ) ), servers = dict ( required = True , type = 'list' , elements = 'dict' , options = dict ( connectivity_type = dict ( type = 'str' , required = True ), count = dict ( type = 'int' , required = True ), ip_version = dict ( type = 'str' , required = True ), label = dict ( type = 'str' , required = True ), links = dict ( required = True , type = 'list' , elements = 'dict' , options = dict ( attachment_type = dict ( type = 'str' , required = True ), label = dict ( type = 'str' , required = True ), lag_mode = dict ( type = 'str' , required = False ), link_per_switch_count = dict ( type = 'int' , required = False ), link_speed = dict ( required = True , type = 'dict' , options = dict ( unit = dict ( type = 'str' , required = False ), value = dict ( type = 'int' , required = False ) ) ), target_switch_label = dict ( type = 'str' , required = True ) ) ), logical_device = dict ( type = 'str' , required = True ), port_channel_id_max = dict ( type = 'int' , required = False ), port_channel_id_min = dict ( type = 'int' , required = False ) ) ) ) ), spine = dict ( required = True , type = 'dict' , options = dict ( count = dict ( required = True , type = 'int' ), external_link_count = dict ( required = True , type = 'int' ), external_link_speed = dict ( required = True , type = 'str' ), link_per_superspine_count = dict ( required = True , type = 'int' ), link_per_superspine_speed = dict ( required = True , type = 'str' ), logical_device = dict ( required = True , type = 'dict' , options = dict ( display_name = dict ( required = True , type = 'str' ), id = dict ( required = True , type = 'str' ), panels = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( panel_layout = dict ( required = False , type = 'dict' , options = dict ( column_count = dict ( required = False , type = 'int' ), row_count = dict ( required = False , type = 'int' ) ) ), port_groups = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( count = dict ( required = False , type = 'int' ), roles = dict ( required = False , type = 'list' , elements = 'str' ), speed = dict ( required = False , type = 'dict' , options = dict ( unit = dict ( required = False , type = 'str' ), value = dict ( required = False , type = 'int' ) ) ) ) ), port_indexing = dict ( required = False , type = 'dict' , options = dict ( order = dict ( type = 'str' , required = False ), schema = dict ( type = 'str' , required = False ), start_index = dict ( type = 'int' , required = False ) ) ) ) ) ) ) ) ), type = dict ( required = True , type = 'str' ), virtual_network_policy = dict ( required = True , type = 'dict' , options = dict ( overlay_control_protocol = dict ( required = True , type = 'str' ) ) ) ) ), type = dict ( required = True , choices = [ 'logical-devices' , 'interface-maps' , 'rack-types' , 'templates' ], type = 'str' ), validate_certs = dict ( type = 'bool' , required = False , default = False ), )","title":"Workspace"},{"location":"docs/terraform/workspaces/ike/#overview","text":"The cdot65.apstra.design module will allow you to manage your design elements within Apstra. Feature set as of version 0.0.14: manage Logical Devices, Rack Types, Templates, Intereface Mapping idempotent Suported Resources: Design Element How to specify within Ansible module parameter \"type\" Interface Mapping interface-maps Logical Device logical-devices Rack Types rack-types Templates templates","title":"\ud83d\udccc Overview"},{"location":"docs/terraform/workspaces/ike/#example","text":"- name : Create a logical device cdot65.apstra.design : # define how to connect to Apstra server server : apstra.dmz.home port : 443 validate_certs : False api_token : \"{{ api_token }}\" # define design element (a new logical device) type : \"logical-devices\" display_name : \"cool-switch-vendor\" panels : - panel_layout : # rack unit height and width row_count : 1 column_count : 12 port_indexing : # top to bottom, left to right, start with number 1 order : \"T-B, L-R\" schema : \"absolute\" start_index : 1 port_groups : # 12 interfaces, all capable of a leaf role with 10GbE - count : 12 roles : - leaf speed : value : 10 unit : \"G\" # state whether you want to create or delete this resource state : present","title":"Example"},{"location":"docs/terraform/workspaces/ike/#options","text":"If you'd like to see the options available for you within the module, have a look at the data model provided below. Option Type Description access_switches list standby api_token string our API token to authenticate with Apstra description string standby device_profile_id string standby display_name int standby id string standby interfaces list standby label string standby leafs list standby logical_devices list standby logical_device_id str standby name str standby panels dict standby port int standby server str standby servers list standby state str standby design_template dict standby type str standby validate_certs bool standby","title":"Options"},{"location":"docs/terraform/workspaces/ike/#data-model","text":"We can also get insight on all available options, and their expected input types, by looking at the module's data model. @staticmethod def design_spec (): return dict ( access_switches = dict ( required = False , type = 'list' , elements = 'str' ), api_token = dict ( required = True , fallback = ( env_fallback , [ 'APSTRA_API_TOKEN' , 'API_TOKEN' ] ), no_log = True , type = 'str' ), description = dict ( required = False , type = 'str' ), device_profile_id = dict ( required = False , type = 'str' ), display_name = dict ( required = True , fallback = ( env_fallback , [ 'APSTRA_USERNAME' , 'USERNAME' ] ), type = 'str' ), id = dict ( required = False , type = 'str' ), interfaces = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( mapping = dict ( required = True , type = 'list' , elements = 'int' ), name = dict ( required = True , type = 'str' , ), position = dict ( required = True , type = 'int' , ), roles = dict ( required = True , type = 'list' , elements = 'str' ), setting = dict ( required = True , type = 'dict' , options = dict ( param = dict ( required = False , type = 'str' ), ) ), speed = dict ( required = True , type = 'dict' , options = dict ( unit = dict ( required = False , type = 'str' ), value = dict ( required = False , type = 'int' ), ) ), state = dict ( required = True , type = 'str' , ), ), ), label = dict ( required = False , type = 'str' ), leafs = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( external_router_facing = dict ( required = True , type = 'bool' , ), external_router_links = dict ( required = True , type = 'list' , elements = 'str' ), label = dict ( required = False , type = 'str' , ), leaf_leaf_l3_link_count = dict ( required = False , type = 'int' , ), leaf_leaf_l3_link_port_channel_id = dict ( required = False , type = 'int' , ), leaf_leaf_l3_link_speed = dict ( required = False , type = 'str' , ), leaf_leaf_link_count = dict ( required = False , type = 'int' , ), leaf_leaf_link_port_channel_id = dict ( required = False , type = 'int' , ), leaf_leaf_link_speed = dict ( required = False , type = 'str' , ), link_per_spine_count = dict ( required = False , type = 'int' , ), link_per_spine_speed = dict ( required = True , type = 'dict' , options = dict ( unit = dict ( required = False , type = 'str' ), value = dict ( required = False , type = 'int' ) ) ), logical_device = dict ( required = False , type = 'str' , ), redundancy_protocol = dict ( required = False , type = 'str' , ), ), ), logical_devices = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( display_name = dict ( required = True , type = 'str' , ), id = dict ( required = True , type = 'str' , ), panels = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( panel_layout = dict ( required = True , type = 'dict' , options = dict ( row_count = dict ( required = False , type = 'int' ), column_count = dict ( required = False , type = 'int' ), ) ), port_indexing = dict ( required = True , type = 'dict' , options = dict ( order = dict ( required = False , type = 'str' ), start_index = dict ( required = False , type = 'int' ), schema = dict ( required = False , type = 'str' ), ) ), port_groups = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( count = dict ( required = False , type = 'int' ), roles = dict ( required = False , type = 'list' , elements = 'str' ), speed = dict ( required = True , type = 'dict' , options = dict ( unit = dict ( required = False , type = 'str' ), value = dict ( required = False , type = 'int' ), ) ), ), ), ), ), ), ), logical_device_id = dict ( required = False , type = 'str' ), name = dict ( required = False , type = 'str' ), panels = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( panel_layout = dict ( required = True , type = 'dict' , options = dict ( row_count = dict ( required = False , type = 'int' ), column_count = dict ( required = False , type = 'int' ), ) ), port_indexing = dict ( required = True , type = 'dict' , options = dict ( order = dict ( required = False , type = 'str' ), schema = dict ( required = False , type = 'str' ), start_index = dict ( required = False , type = 'int' ), ), ), port_groups = dict ( required = True , type = 'list' , elements = 'dict' , options = dict ( count = dict ( required = False , type = 'int' ), roles = dict ( required = False , type = 'list' , elements = 'str' ), speed = dict ( required = False , type = 'dict' , options = dict ( value = dict ( required = False , type = 'int' ), unit = dict ( required = False , type = 'str' ), ), ), ), ), ), ), port = dict ( required = False , type = 'int' ), server = dict ( required = False , type = 'str' ), servers = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( connectivity_type = dict ( required = True , type = 'str' , ), count = dict ( required = True , type = 'int' , ), label = dict ( required = True , type = 'str' , ), logical_device = dict ( required = True , type = 'str' , ), ip_version = dict ( required = True , type = 'str' , ), port_channel_id_min = dict ( required = True , type = 'int' , ), port_channel_id_max = dict ( required = True , type = 'int' , ), links = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( attachment_type = dict ( required = False , type = 'str' ), label = dict ( required = False , type = 'str' ), lag_mode = dict ( required = False , type = 'str' ), leaf_peer = dict ( required = False , type = 'str' ), link_per_switch_count = dict ( required = False , type = 'int' ), link_speed = dict ( required = True , type = 'dict' , options = dict ( unit = dict ( required = False , type = 'str' ), value = dict ( required = False , type = 'int' ), ) ), target_switch_label = dict ( required = False , type = 'str' ), ), ), ), ), state = dict ( required = True , choices = [ 'absent' , 'present' ], type = 'str' ), design_template = dict ( required = False , type = 'dict' , options = dict ( asn_allocation_policy = dict ( required = False , type = 'dict' , options = dict ( spine_asn_scheme = dict ( required = False , type = 'str' ) ) ), dhcp_service_intent = dict ( required = False , type = 'dict' , options = dict ( active = dict ( required = False , type = 'bool' ) ) ), display_name = dict ( required = True , type = 'str' ), external_routing_policy = dict ( required = False , type = 'dict' , options = dict ( export_policy = dict ( required = False , type = 'dict' , options = dict ( all_routes = dict ( required = False , type = 'bool' ), l2edge_subnets = dict ( required = False , type = 'bool' ), l3edge_server_links = dict ( required = False , type = 'bool' ), loopbacks = dict ( required = False , type = 'bool' ), spine_leaf_links = dict ( required = False , type = 'bool' ), ) ), import_policy = dict ( required = False , type = 'str' ) ) ), fabric_addressing_policy = dict ( required = False , type = 'dict' , options = dict ( spine_leaf_links = dict ( required = False , type = 'str' ) ) ), rack_type_counts = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( count = dict ( required = False , type = 'int' ), rack_type_id = dict ( required = False , type = 'str' ), ) ), rack_types = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( access_switches = dict ( required = False , type = 'list' , elements = 'str' ), description = dict ( required = False , type = 'str' ), display_name = dict ( required = False , type = 'str' ), id = dict ( required = False , type = 'str' ), leafs = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( external_router_facing = dict ( required = False , type = 'bool' ), external_router_links = dict ( required = False , type = 'list' , elements = 'str' ), label = dict ( required = False , type = 'str' ), leaf_leaf_l3_link_count = dict ( required = False , type = 'int' ), leaf_leaf_l3_link_port_channel_id = dict ( required = False , type = 'int' ), leaf_leaf_l3_link_speed = dict ( required = False , type = 'str' ), leaf_leaf_link_count = dict ( required = False , type = 'int' ), leaf_leaf_link_port_channel_id = dict ( required = False , type = 'int' ), leaf_leaf_link_speed = dict ( required = False , type = 'str' ), link_per_spine_count = dict ( required = False , type = 'int' ), link_per_spine_speed = dict ( required = False , type = 'dict' , options = dict ( unit = dict ( type = 'str' , required = False ), value = dict ( type = 'int' , required = False ) ) ), logical_device = dict ( required = True , type = 'str' ), redundancy_protocol = dict ( required = False , type = 'str' ), ) ), logical_devices = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( display_name = dict ( required = True , type = 'str' ), id = dict ( required = True , type = 'str' ), panels = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( panel_layout = dict ( required = False , type = 'dict' , options = dict ( column_count = dict ( required = False , type = 'int' ), row_count = dict ( required = False , type = 'int' ) ) ), port_groups = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( count = dict ( required = False , type = 'int' ), roles = dict ( required = False , type = 'list' , elements = 'str' ), speed = dict ( required = False , type = 'dict' , options = dict ( unit = dict ( required = False , type = 'str' ), value = dict ( required = False , type = 'int' ), ) ), ) ), port_indexing = dict ( required = True , type = 'dict' , options = dict ( order = dict ( required = True , type = 'str' ), schema = dict ( required = True , type = 'str' ), start_index = dict ( required = True , type = 'int' ), ) ) ) ) ) ), servers = dict ( required = True , type = 'list' , elements = 'dict' , options = dict ( connectivity_type = dict ( type = 'str' , required = True ), count = dict ( type = 'int' , required = True ), ip_version = dict ( type = 'str' , required = True ), label = dict ( type = 'str' , required = True ), links = dict ( required = True , type = 'list' , elements = 'dict' , options = dict ( attachment_type = dict ( type = 'str' , required = True ), label = dict ( type = 'str' , required = True ), lag_mode = dict ( type = 'str' , required = False ), link_per_switch_count = dict ( type = 'int' , required = False ), link_speed = dict ( required = True , type = 'dict' , options = dict ( unit = dict ( type = 'str' , required = False ), value = dict ( type = 'int' , required = False ) ) ), target_switch_label = dict ( type = 'str' , required = True ) ) ), logical_device = dict ( type = 'str' , required = True ), port_channel_id_max = dict ( type = 'int' , required = False ), port_channel_id_min = dict ( type = 'int' , required = False ) ) ) ) ), spine = dict ( required = True , type = 'dict' , options = dict ( count = dict ( required = True , type = 'int' ), external_link_count = dict ( required = True , type = 'int' ), external_link_speed = dict ( required = True , type = 'str' ), link_per_superspine_count = dict ( required = True , type = 'int' ), link_per_superspine_speed = dict ( required = True , type = 'str' ), logical_device = dict ( required = True , type = 'dict' , options = dict ( display_name = dict ( required = True , type = 'str' ), id = dict ( required = True , type = 'str' ), panels = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( panel_layout = dict ( required = False , type = 'dict' , options = dict ( column_count = dict ( required = False , type = 'int' ), row_count = dict ( required = False , type = 'int' ) ) ), port_groups = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( count = dict ( required = False , type = 'int' ), roles = dict ( required = False , type = 'list' , elements = 'str' ), speed = dict ( required = False , type = 'dict' , options = dict ( unit = dict ( required = False , type = 'str' ), value = dict ( required = False , type = 'int' ) ) ) ) ), port_indexing = dict ( required = False , type = 'dict' , options = dict ( order = dict ( type = 'str' , required = False ), schema = dict ( type = 'str' , required = False ), start_index = dict ( type = 'int' , required = False ) ) ) ) ) ) ) ) ), type = dict ( required = True , type = 'str' ), virtual_network_policy = dict ( required = True , type = 'dict' , options = dict ( overlay_control_protocol = dict ( required = True , type = 'str' ) ) ) ) ), type = dict ( required = True , choices = [ 'logical-devices' , 'interface-maps' , 'rack-types' , 'templates' ], type = 'str' ), validate_certs = dict ( type = 'bool' , required = False , default = False ), )","title":"Data Model"},{"location":"docs/terraform/workspaces/ipsec/","text":"\ud83d\udccc Overview The cdot65.apstra.resources module will allow you to manage the configuration of your Blueprint within Apstra. Feature set as of version 0.0.7: manage all resources supports tagging idempotent Suported Resources: Resource Type Ansible module parameter \"type\" ASN Pool asn-pools IPv4 Pool ip-pools IPv6 Pool ipv6-pools VLAN Pool vlan-pools VNI Pool vni-pools Example Here is a basic example of using the module to manage your resources within in Apstra - name : Create an IP Pool Resource with two prefixes cdot65.apstra.resources : # define server connectivity options server : apstra.dmz.home port : 443 validate_certs : False api_token : \"{{ api_token }}\" # define resource allocations display_name : \"Windows Servers\" tags : [] type : \"ip-pools\" subnets : - \"100.1.1.0/24\" - \"100.1.2.0/24\" # state whether you want to create or delete this resource state : present # store the output of our task as a new variable to debug later register : windows_servers_ippool Options If you'd like to see the options available for you within the module, have a look at the data model provided below. Option Type Description api_token string our API token to authenticate with Apstra address string standby asn int standby display_name string standby ipv6_address string standby port int standby ranges list standby subnets list standby server string Apstra's DNS hostname or IP address state string determine whether to create or delete resource tags list standby type string standby validate_certs bool enable or disable SSL certificate validation Data Model We can also get insight on all available options, and their expected input types, by looking at the module's data model. @staticmethod def resources_spec (): return dict ( address = dict ( required = False , type = 'str' ), asn = dict ( required = False , type = 'int' ), api_token = dict ( required = True , fallback = ( env_fallback , [ 'APSTRA_API_TOKEN' , 'APSTRA_API_TOKEN' , 'API_TOKEN' ]), no_log = True , type = 'str' ), display_name = dict ( required = True , fallback = ( env_fallback , [ 'APSTRA_USERNAME' , 'APSTRA_USERNAME' , 'USERNAME' ]), type = 'str' ), ipv6_address = dict ( required = False , type = 'str' ), port = dict ( required = True , type = 'int' ), ranges = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( first = dict ( required = True , type = 'int' ), last = dict ( required = True , type = 'int' ), ), ), server = dict ( required = False , type = 'str' ), state = dict ( required = False , choices = [ 'absent' , 'present' ], type = 'str' ), subnets = dict ( required = False , type = 'list' , elements = 'str' ), tags = dict ( required = False , type = 'list' , elements = 'str' ), type = dict ( required = True , choices = [ 'asn-pools' , 'external-routers' , 'ip-pools' , 'ipv6-pools' , 'vlan-pools' , 'vni-pools' ], type = 'str' ), validate_certs = dict ( type = 'bool' , required = False , default = False ), )","title":"Workspace"},{"location":"docs/terraform/workspaces/ipsec/#overview","text":"The cdot65.apstra.resources module will allow you to manage the configuration of your Blueprint within Apstra. Feature set as of version 0.0.7: manage all resources supports tagging idempotent Suported Resources: Resource Type Ansible module parameter \"type\" ASN Pool asn-pools IPv4 Pool ip-pools IPv6 Pool ipv6-pools VLAN Pool vlan-pools VNI Pool vni-pools","title":"\ud83d\udccc Overview"},{"location":"docs/terraform/workspaces/ipsec/#example","text":"Here is a basic example of using the module to manage your resources within in Apstra - name : Create an IP Pool Resource with two prefixes cdot65.apstra.resources : # define server connectivity options server : apstra.dmz.home port : 443 validate_certs : False api_token : \"{{ api_token }}\" # define resource allocations display_name : \"Windows Servers\" tags : [] type : \"ip-pools\" subnets : - \"100.1.1.0/24\" - \"100.1.2.0/24\" # state whether you want to create or delete this resource state : present # store the output of our task as a new variable to debug later register : windows_servers_ippool","title":"Example"},{"location":"docs/terraform/workspaces/ipsec/#options","text":"If you'd like to see the options available for you within the module, have a look at the data model provided below. Option Type Description api_token string our API token to authenticate with Apstra address string standby asn int standby display_name string standby ipv6_address string standby port int standby ranges list standby subnets list standby server string Apstra's DNS hostname or IP address state string determine whether to create or delete resource tags list standby type string standby validate_certs bool enable or disable SSL certificate validation","title":"Options"},{"location":"docs/terraform/workspaces/ipsec/#data-model","text":"We can also get insight on all available options, and their expected input types, by looking at the module's data model. @staticmethod def resources_spec (): return dict ( address = dict ( required = False , type = 'str' ), asn = dict ( required = False , type = 'int' ), api_token = dict ( required = True , fallback = ( env_fallback , [ 'APSTRA_API_TOKEN' , 'APSTRA_API_TOKEN' , 'API_TOKEN' ]), no_log = True , type = 'str' ), display_name = dict ( required = True , fallback = ( env_fallback , [ 'APSTRA_USERNAME' , 'APSTRA_USERNAME' , 'USERNAME' ]), type = 'str' ), ipv6_address = dict ( required = False , type = 'str' ), port = dict ( required = True , type = 'int' ), ranges = dict ( required = False , type = 'list' , elements = 'dict' , options = dict ( first = dict ( required = True , type = 'int' ), last = dict ( required = True , type = 'int' ), ), ), server = dict ( required = False , type = 'str' ), state = dict ( required = False , choices = [ 'absent' , 'present' ], type = 'str' ), subnets = dict ( required = False , type = 'list' , elements = 'str' ), tags = dict ( required = False , type = 'list' , elements = 'str' ), type = dict ( required = True , choices = [ 'asn-pools' , 'external-routers' , 'ip-pools' , 'ipv6-pools' , 'vlan-pools' , 'vni-pools' ], type = 'str' ), validate_certs = dict ( type = 'bool' , required = False , default = False ), )","title":"Data Model"}]}